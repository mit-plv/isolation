(* Require Import koika.Frontend. *)
(* Require Import koikaExamples.Enclaves.Common. *)
(* Require Import koikaExamples.Enclaves.TypeDefs. *)
(* Require Import koikaExamples.Enclaves.Impl. *)
(* Require Import koikaExamples.Enclaves.Spec. *)
(* Require Import koikaExamples.Enclaves.Theorem. *)
(* Require Import koikaExamples.Enclaves.Utils. *)
(* Require Import FunctionalExtensionality. *)
(* Require Import koikaExamples.Enclaves.ExtractionUtils. *)

(* Require Import koika.Symbolic. *)
(* Import ListNotations. *)
(*   Inductive custom_prop_names:= *)
(*   | Custom_SimPreStepSM__running *)
(*   | Custom_SimPreStepSM__valid *)
(*   | Custom_SimPreStepSM__led *)
(*   | Custom_SimPreStepSM__uart_read *)
(*   | Custom_SimPreStepSM__uart_write *)
(*   | Custom_SimInvariant__reg_sim *)
(*   | Custom_SimInvariant__valid_addrs_impl *)
(*   | Custom_SimInvariant__valid_addrs_impl_other' *)
(*   | Custom_SimInvariant__valid_addrs_impl_other *)
(*   | Custom_SimInvariant__valid_addrs_spec *)
(*   | Custom_ImplInvariant__mmio_req_in_range0 *)
(*   | Custom_ImplInvariant__mmio_req_in_range1 *)
(*   | Custom_ImplInvariant__disjoint_configs *)
(*   | Custom_ImplInvariant__disjoint_eid *)
(*   | Custom_ImplInvariant__disjoint_sid *)
(*   | Custom_ImplInvariant__reset0 *)
(*   | Custom_ImplInvariant__reset1 *)
(*   | Custom_ImplInvariant__reset_mem0 *)
(*   | Custom_ImplInvariant__reset_mem1 *)
(*   | Custom_ImplInvariant__running_inv0 *)
(*   | Custom_ImplInvariant__running_inv1 *)
(*   | Custom_ImplInvariant__enc_req0 *)
(*   | Custom_ImplInvariant__enc_req1 *)
(*   | Custom_SimInvariant__other_mmio_empty *)
(*   | Custom_SimPostStepSM__led *)
(*   | Custom_SimPostStepSM__uart_read *)
(*   | Custom_SimPostStepSM__uart_write *)
(*   | Custom_SimPostStepSM__config_preserved *)
(*   | Custom_PostStepSM__no_write_impl *)
(*   | Custom_PostStepSM__no_write_spec *)
(*   | Custom_PostStepSM__ext_push_impl *)
(*   | Custom_PostStepSM__ext_push_spec *)
(*   | Custom_PostStepSM__config_same0 *)
(*   | Custom_other (str: string) *)
(*   . *)

(* Lemma config_led_iff: *)
(*   forall data config, *)
(*   unsafe_enclave_data_to_config data = config -> *)
(*   config_ext_led config = true <-> *)
(*     unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_led *)
(*       (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data data) = Ob~1. *)
(* Proof. *)
(*   unfold unsafe_enclave_data_to_config. intros; subst; simpl. rewrite beq_dec_iff. reflexivity. *)
(* Qed. *)
(*   Lemma config_uart_iff: *)
(*     forall data config, *)
(*     unsafe_enclave_data_to_config data = config -> *)
(*     config_ext_uart config = true <-> *)
(*       unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_uart *)
(*         (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data data) = Ob~1. *)
(*   Proof. *)
(*     unfold unsafe_enclave_data_to_config. intros; subst; simpl. rewrite beq_dec_iff. reflexivity. *)
(*   Qed. *)

(* Module Type SM_Proof (EnclaveParams: EnclaveParams_sig) *)
(*                      (SecurityParams: SecurityParams_sig EnclaveParams). *)
(*   Module Import Implementation := Empty <+ SecurityParams.Implementation. *)
(*   Module SM := Machine.SM. *)
(*   Instance Show_sm_rule : Show sm_rule_name_t := *)
(*   { show := show_sm_rule }. *)

(*   Section ImplMachine. *)
(*     Notation reg_t := (@reg_t debug_id_ty). *)
(*     Definition impl_schedule_list : list (sm_rule_name_t * string) := *)
(*       map (fun rl => (rl, show rl)) (list_of_schedule (Implementation.Machine.SM.schedule)). *)
(*     Definition impl_typecheck_fn rl : result (action * nat) unit := *)
(*       typecheck_rule SM.reg_list ext_fn_types_list SM.int_fns SM.struct_defs *)
(*               (inline_rule SM.int_fns rl). *)
(*     Definition impl_schedule := *)
(*       preprocess_schedule impl_typecheck_fn SM.rules impl_schedule_list. *)
(*     (* Goal preprocess_schedule_success impl_typecheck_fn SM.rules impl_schedule_list = true. *) *)
(*     (* Proof. vm_compute; reflexivity. Qed. *) *)
(*     Definition impl_machine : machine_t := *)
(*       {| file_registers := SM.reg_list; *)
(*          file_ext_sigma := ext_fn_tys; *)
(*          file_struct_defs := SM.struct_defs; *)
(*       |}. *)

(*   End ImplMachine. *)

(*   Section SpecMachine0. *)

(*     Definition spec0_schedule_list : list (sm_rule_name_t * string) := *)
(*       map (fun rl => (rl, show rl)) (list_of_schedule Spec0.sm0_schedule). *)
(*     Definition spec0_typecheck_fn rl : result (action * nat) unit := *)
(*       typecheck_rule Machine.SM.reg_list ext_fn_types_list Machine.SM.int_fns Machine.SM.struct_defs *)
(*               (inline_rule Machine.SM.int_fns rl). *)
(*     Definition spec0_schedule := *)
(*       preprocess_schedule spec0_typecheck_fn Machine.SM.rules spec0_schedule_list. *)

(*     (* Goal preprocess_schedule_success impl_typecheck_fn Machine.SM.rules spec0_schedule_list = true. *) *)
(*     (* Proof. vm_compute; reflexivity. Qed. *) *)

(*     Definition spec0_machine : machine_t := *)
(*       {| file_registers := Machine.SM.reg_list; *)
(*          file_ext_sigma := ext_fn_tys; *)
(*          file_struct_defs := Machine.struct_defs; *)
(*       |}. *)
(*   End SpecMachine0. *)

(*   Import PfHelpers. *)
(*   Notation "'interp_machine' '(' sigma ')' state" := (interp_scheduler sigma *)
(*                  (id_transform_int_fn_env _id SM.int_fns) *)
(*                  (id_transform_struct_env _id SM.struct_defs) (state) *)
(*                  (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl))) (at level 1). *)
(*   Definition senc_data_valid (core: ind_core_id) (reg_fn: reg_t -> sval) get_field : sval := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__valid (reg_fn (SM.lookup_reg_enc_data core)). *)

(*   Definition foo_req_addrs_in_range *)
(*     (core: ind_core_id) (reg_fn: reg_t -> sval) (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) : fancy_spred := *)
(*     let (to_imem_data, to_imem_valid) := match core with *)
(*                                          | CoreId0 => (SM.Memory.toIMem0.REG_data0, SM.Memory.toIMem0.REG_valid0) *)
(*                                          | CoreId1 => (SM.Memory.toIMem1.REG_data0, SM.Memory.toIMem1.REG_valid0) *)
(*                                          end in *)
(*     let (to_dmem_data, to_dmem_valid) := match core with *)
(*                                          | CoreId0 => (SM.Memory.toDMem0.REG_data0, SM.Memory.toDMem0.REG_valid0) *)
(*                                          | CoreId1 => (SM.Memory.toDMem1.REG_data0, SM.Memory.toDMem1.REG_valid0) *)
(*                                          end in *)
(*     {{{ `senc_data_valid core reg_fn get_field` = Ob~1 -> *)
(*         ``foo_fifo_req_addrs_in_range EnclaveParams.enclave_sig reg_fn get_field to_imem_valid to_imem_data (SM.lookup_reg_enc_data core) `` /\ *)
(*         ``foo_fifo_req_addrs_in_range EnclaveParams.enclave_sig reg_fn get_field to_dmem_valid to_dmem_data (SM.lookup_reg_enc_data core) `` *)
(*     }}}. *)
(*   Definition enc_data_valid (core: ind_core_id) (st: koika_state_t) := *)
(*     (unsafe_get_field enclave_data.(dstruct_fields) FLD_enclave_data__valid *)
(*                                                            st.[_id (SM.lookup_reg_enc_data core)]). *)

(*   Definition req_addrs_in_range (core: ind_core_id) (st: Environments.state_t) (config: enclave_config) : Prop := *)
(*     let (to_imem_data, to_imem_valid) := match core with *)
(*                                          | CoreId0 => (SM.Memory.toIMem0.REG_data0, SM.Memory.toIMem0.REG_valid0) *)
(*                                          | CoreId1 => (SM.Memory.toIMem1.REG_data0, SM.Memory.toIMem1.REG_valid0) *)
(*                                          end in *)
(*     let (to_dmem_data, to_dmem_valid) := match core with *)
(*                                          | CoreId0 => (SM.Memory.toDMem0.REG_data0, SM.Memory.toDMem0.REG_valid0) *)
(*                                          | CoreId1 => (SM.Memory.toDMem1.REG_data0, SM.Memory.toDMem1.REG_valid0) *)
(*                                          end in *)
(*     enc_data_valid core st = Ob~1 -> *)
(*     fifo_addrs_in_range EnclaveParams.enclave_sig st config (_id to_imem_valid) (_id to_imem_data) /\ *)
(*     fifo_addrs_in_range EnclaveParams.enclave_sig st config (_id to_dmem_valid) (_id to_dmem_data). *)

(*   Definition req_addrs_not_in_range (core: ind_core_id) (st: Environments.state_t) (config: enclave_config) : Prop := *)
(*     let (to_imem_data, to_imem_valid) := match core with *)
(*                                          | CoreId0 => (SM.Memory.toIMem0.REG_data0, SM.Memory.toIMem0.REG_valid0) *)
(*                                          | CoreId1 => (SM.Memory.toIMem1.REG_data0, SM.Memory.toIMem1.REG_valid0) *)
(*                                          end in *)
(*     let (to_dmem_data, to_dmem_valid) := match core with *)
(*                                          | CoreId0 => (SM.Memory.toDMem0.REG_data0, SM.Memory.toDMem0.REG_valid0) *)
(*                                          | CoreId1 => (SM.Memory.toDMem1.REG_data0, SM.Memory.toDMem1.REG_valid0) *)
(*                                          end in *)
(*     enc_data_valid (other_core core) st = Ob~1 -> *)
(*     fifo_addrs_not_in_range EnclaveParams.enclave_sig st config (_id to_imem_valid) (_id to_imem_data) /\ *)
(*     fifo_addrs_not_in_range EnclaveParams.enclave_sig st config (_id to_dmem_valid) (_id to_dmem_data). *)



(*   Instance EqDec_custom_prop_names : EqDec custom_prop_names := _. *)

(*   Definition dummy_impl_init_st_machine (impl_st: koika_state_t) := *)
(*     {| pkg_machine := impl_machine; *)
(*                               pkg_init_st := impl_st; *)
(*                               pkg_sigma := fun _ _ => Failure tt; (* don't care *) *)
(*                               pkg_mid_st := None; *)
(*                               pkg_final_st := impl_st; (* don't care *) *)
(*                               pkg_mid_ext_log := None; (* don't care *) *)
(*                               pkg_ext_log' := SortedExtFnEnv.empty (* don't care *) *)
(*                            |} . *)
(*   (* config valid *) *)
(*   Definition mmio_req_in_range *)
(*     (core: ind_core_id) (st: koika_state_t) : Prop := *)
(*     let (to_mmio_data, to_mmio_valid) := *)
(*       match core with *)
(*       | CoreId0 => (SM.toMMIO0.REG_data0, SM.toMMIO0.REG_valid0) *)
(*       | CoreId1 => (SM.toMMIO1.REG_data0, SM.toMMIO1.REG_valid0) *)
(*       end in *)
(*     let enc_data := (unsafe_get_field enclave_data.(dstruct_fields) FLD_enclave_data__data                                                      st.[_id (SM.lookup_reg_enc_data core)]) in *)
(*     enc_data_valid core st = Ob~1 -> *)
(*     st.[_id to_mmio_valid] = Ob~1 -> *)
(*     (unsafe_get_field mem_req.(dstruct_fields) FLD_mem_req__addr st.[_id to_mmio_data] = MMIO_UART_ADDRESS -> *)
(*      unsafe_get_field enclave_req.(dstruct_fields) FLD_enclave_req__ext_uart enc_data = Ob~1 ) /\ *)
(*     (unsafe_get_field mem_req.(dstruct_fields) FLD_mem_req__addr st.[_id to_mmio_data] = MMIO_LED_ADDRESS -> *)
(*      unsafe_get_field enclave_req.(dstruct_fields) FLD_enclave_req__ext_led enc_data = Ob~1 ). *)

(*   Definition foo_disjoint_eid (reg_fn: reg_t -> sval) (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) *)
(*     : fancy_spred := *)
(*      let sval_enclave_data0 := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__data (reg_fn (SM.lookup_reg_enc_data CoreId0))  in *)
(*      let sval_enclave_data1 := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__data (reg_fn (SM.lookup_reg_enc_data CoreId1))  in *)
(*     {{{ `senc_data_valid CoreId0 reg_fn get_field` = Ob~1 -> *)
(*         `senc_data_valid CoreId1 reg_fn get_field` = Ob~1 -> *)
(*         `get_field enclave_req.(sid) FLD_enclave_req__eid sval_enclave_data0` <> *)
(*         `get_field enclave_req.(sid) FLD_enclave_req__eid sval_enclave_data1` *)
(*     }}}. *)

(*   Definition foo_disjoint_sid (reg_fn: reg_t -> sval) (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) *)
(*     : fancy_spred := *)
(*      let sval_enclave_data0 := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__data (reg_fn (SM.lookup_reg_enc_data CoreId0))  in *)
(*      let sval_enclave_data1 := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__data (reg_fn (SM.lookup_reg_enc_data CoreId1))  in *)
(*     {{{ `senc_data_valid CoreId0 reg_fn get_field` = Ob~1 -> *)
(*         `senc_data_valid CoreId1 reg_fn get_field` = Ob~1 -> *)
(*         `get_field enclave_req.(sid) FLD_enclave_req__shared_regions sval_enclave_data0` && *)
(*         `get_field enclave_req.(sid) FLD_enclave_req__shared_regions sval_enclave_data1` = Ob~0~0~0~0~0~0 *)
(*     }}}. *)

(*   Definition foo_reset_correct (core: ind_core_id) *)
(*                                (reg_fn: reg_t -> sval) *)
(*                                (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) *)
(*                                : fancy_spred := *)
(*     let to_mmio_valid := *)
(*       match core with *)
(*       | CoreId0 => (SM.toMMIO0.REG_valid0) *)
(*       | CoreId1 => (SM.toMMIO1.REG_valid0) *)
(*       end in *)
(*     let mem_purge_reg := *)
(*       match core with *)
(*       | CoreId0 => SM.Memory.REG_purge0 *)
(*       | CoreId1 => SM.Memory.REG_purge1 *)
(*       end in *)
(*     {{{ *)
(*          { `senc_data_valid core reg_fn get_field` = Ob~0 -> *)
(*            `reg_fn (SM.lookup_reg_state core)` = #ENUM_core_state__WAITING } /\ *)
(*          {`reg_fn (SM.lookup_reg_state core)` = #ENUM_core_state__WAITING  -> *)
(*           `senc_data_valid core reg_fn get_field` = Ob~0 /\ *)
(*           `reg_fn to_mmio_valid` = Ob~0 /\ *)
(*           `reg_fn mem_purge_reg` = #ENUM_purge_state__PURGED *)
(*          } /\ *)
(*          { `reg_fn (SM.lookup_sm_reset_state core)` = Ob~1 -> *)
(*            `reg_fn to_mmio_valid` = Ob~0 *)
(*          } /\ *)
(*          { {`reg_fn (SM.lookup_reg_state core)` = #ENUM_core_state__RUNNING \/ *)
(*            `reg_fn (SM.lookup_reg_state core)` = #ENUM_core_state__WAITING } -> *)
(*            `reg_fn (SM.lookup_sm_reset_state core)` = Ob~0 *)
(*          } *)
(*     }}}. *)

(*   (* unsafe_get_field [(FLD_enclave_data__data, 10); (FLD_enclave_data__valid, 1)] *) *)
(*   (*   FLD_enclave_data__valid impl_st.[_id SM.REG_enc_data1] = Ob~0 \/ *) *)
(*   (* impl_st'.[_id SM.Memory.REG_purge1] = ENUM_purge_state__PURGED -> *) *)
(*   (* impl_st'.[_id SM.Memory.toIMem1.REG_valid0] = Ob~0 /\ *) *)
(*   (* impl_st'.[_id SM.Memory.toDMem1.REG_valid0] = Ob~0 *) *)


(*   (* config invalid \/ mem purged -> ... *) *)
(*   Definition foo_reset_mem_correct (core: ind_core_id) *)
(*                                    (reg_fn: reg_t -> sval) *)
(*                                    (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) *)
(*                                    : fancy_spred := *)
(*     let mem_purge := match core with *)
(*                      | CoreId0 => SM.Memory.REG_purge0 *)
(*                      | CoreId1 => SM.Memory.REG_purge1 *)
(*                      end in *)
(*     let '(to_imem_valid, to_dmem_valid) := *)
(*       match core with *)
(*       | CoreId0 => (SM.Memory.toIMem0.REG_valid0, SM.Memory.toDMem0.REG_valid0) *)
(*       | CoreId1 => (SM.Memory.toIMem1.REG_valid0, SM.Memory.toDMem1.REG_valid0) *)
(*       end in *)

(*     {{{ {`senc_data_valid core reg_fn get_field` = Ob~0 \/ *)
(*           `reg_fn mem_purge` = #ENUM_purge_state__PURGED } -> *)
(*         `reg_fn to_imem_valid` = Ob~0 /\ *)
(*         `reg_fn to_dmem_valid` = Ob~0 *)
(*     }}}. *)

(*   Definition foo_running_inv (core: ind_core_id) *)
(*                          (reg_fn: reg_t -> sval) *)
(*                          (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) *)
(*                          : fancy_spred := *)
(*     let mem_purge := match core with *)
(*                      | CoreId0 => SM.Memory.REG_purge0 *)
(*                      | CoreId1 => SM.Memory.REG_purge1 *)
(*                      end in *)
(*     let core_purge := match core with *)
(*                      | CoreId0 => SM.Core0.REG_purge *)
(*                      | CoreId1 => SM.Core1.REG_purge *)
(*                      end in *)
(*     let state := SM.lookup_reg_state core in *)
(*     {{{ `reg_fn state` = #ENUM_core_state__RUNNING -> *)
(*         `senc_data_valid core reg_fn get_field` = Ob~1 /\ *)
(*         `reg_fn mem_purge` = #ENUM_purge_state__READY *)
(*         (* `reg_fn core_purge` = #ENUM_purge_state__READY *) *)
(*     }}}. *)

(*   Definition foo_enc_req (core: ind_core_id) *)
(*                          (reg_fn: reg_t -> sval) *)
(*                          (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) *)
(*                          : fancy_spred := *)
(*     let state := SM.lookup_reg_state core in *)
(*     {{{ {`reg_fn state` = #ENUM_core_state__PURGING \/ *)
(*         `reg_fn state` = #ENUM_core_state__WAITING} -> *)
(*         `get_field enclave_data.(sid) FLD_enclave_data__valid  (reg_fn (SM.lookup_reg_enc_req core))` = Ob~1 *)
(*     }}}. *)



(*   Definition impl_interp_spred_with_init_st_only (st: state_t) := *)
(*     interp_fancy_spred *)
(*       {| pkg_machine := impl_machine; *)
(*          pkg_init_st := st; *)
(*          pkg_sigma := fun _ _ => Failure tt; (* don't care *) *)
(*          pkg_mid_st := None; *)
(*          pkg_final_st := st; (* don't care *) *)
(*          pkg_mid_ext_log := None; *)
(*          pkg_ext_log' := SortedExtFnEnv.empty (* don't care *) *)
(*       |} . *)
(*   Record ImplInvariant (impl_st: koika_state_t) : Prop := *)
(*     { ImplInvariant__mmio_req_in_range0 : mmio_req_in_range CoreId0 impl_st; *)
(*       ImplInvariant__mmio_req_in_range1: mmio_req_in_range CoreId1 impl_st; *)
(*       ImplInvariant__disjoint_eid: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_disjoint_eid impl_init impl_get_field); *)
(*       ImplInvariant__disjoint_sid: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_disjoint_sid impl_init impl_get_field); *)
(*       ImplInvariant__disjoint_configs: *)
(*         (unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_led *)
(*                 (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data *)
(*                    impl_st.[_id (SM.lookup_reg_enc_data CoreId0)]) = Ob~0 \/ *)
(*         unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_led *)
(*                 (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data *)
(*                    impl_st.[_id (SM.lookup_reg_enc_data CoreId1)]) = Ob~0) /\ *)
(*         (unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_uart *)
(*                 (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data *)
(*                    impl_st.[_id (SM.lookup_reg_enc_data CoreId0)]) = Ob~0 \/ *)
(*         unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_uart *)
(*                 (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data *)
(*                    impl_st.[_id (SM.lookup_reg_enc_data CoreId1)]) = Ob~0); *)
(*       ImplInvariant__reset_correct0: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_reset_correct CoreId0 impl_init impl_get_field); *)
(*       ImplInvariant__reset_correct1: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_reset_correct CoreId1 impl_init impl_get_field); *)
(*       ImplInvariant__reset_mem_correct0: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_reset_mem_correct CoreId0 impl_init impl_get_field); *)
(*       ImplInvariant__reset_mem_correct1: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_reset_mem_correct CoreId1 impl_init impl_get_field); *)
(*       ImplInvariant__running_inv0: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_running_inv CoreId0 impl_init impl_get_field); *)
(*       ImplInvariant__running_inv1: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_running_inv CoreId1 impl_init impl_get_field); *)
(*       ImplInvariant__enc_req0: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_enc_req CoreId0 impl_init impl_get_field); *)
(*       ImplInvariant__enc_req1: *)
(*         impl_interp_spred_with_init_st_only impl_st (foo_enc_req CoreId1 impl_init impl_get_field); *)
(*     }. *)


(*   Record SimInvariant (core: ind_core_id) *)
(*                       (impl_st: koika_state_t) (spec_st: koika_state_t) (config: enclave_config): Prop := *)
(*     { SimInvariant__sim: forall reg, In reg (sm_regs core) -> *)
(*                               impl_st.[_id reg] = spec_st.[_id reg] *)
(*     ; SimInvariant__valid_addrs__impl: req_addrs_in_range core impl_st config *)
(*     ; SimInvariant__valid_addrs__impl_other: req_addrs_not_in_range (other_core core) impl_st config *)
(*     ; SimInvariant__valid_addrs__spec: req_addrs_in_range core spec_st config *)
(*     ; SimInvariant__other_mmio_empty: spec_st.[_id (match core with *)
(*                                                     | CoreId0 => SM.toMMIO1.REG_valid0 *)
(*                                                     | CoreId1 => SM.toMMIO0.REG_valid0 *)
(*                                                     end)] = Ob~0 *)
(*     ; SimInvariant__ImplInvariant: ImplInvariant impl_st *)
(*     }. *)

(*   (* Parameter sm_running_sim: ind_core_id -> koika_state_t -> option enclave_config -> koika_state_t -> Prop. *) *)
(*   (* Parameter custom_SimPreStepSM: ind_core_id -> koika_state_t -> koika_state_t -> enclave_config -> Prop. *) *)

(*   Record SimPreStepSM (core: ind_core_id) (impl_st: koika_state_t) (spec_st: koika_state_t) *)
(*                       (impl_sigma spec_sigma: @ext_sigma_t N) *)
(*                       (config: enclave_config) : Prop := *)
(*     { SimPreStepSM__Invariant: SimInvariant core impl_st spec_st config *)
(*     ; SimPreStepSM__ghost: unsafe_enclave_data_to_config (impl_st.[_id (SM.lookup_reg_enc_data core)]) = config *)
(*     ; SimPreStepSM__running: impl_st.[_id (SM.lookup_reg_state core)] <> ENUM_core_state__WAITING *)
(*     ; SimPreStepSM__valid: unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__valid *)
(*                            impl_st.[_id (SM.lookup_reg_enc_data core)] = Ob~1 *)
(*     ; SimPreStepSM__sim_led: *)
(*       forall arg, unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_led *)
(*                 (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data *)
(*                    spec_st.[_id (SM.lookup_reg_enc_data core)]) = Ob~1 -> *)
(*               unsafe_call_ext impl_sigma (_id EXTFN_ext_led) arg = unsafe_call_ext spec_sigma (_id EXTFN_ext_led) arg *)
(*     ; SimPreStepSM__sim_uart_read: *)
(*       forall arg, unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_uart *)
(*                 (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data *)
(*                    spec_st.[_id (SM.lookup_reg_enc_data core)]) = Ob~1 -> *)
(*               unsafe_call_ext impl_sigma (_id EXTFN_ext_uart_read) arg = unsafe_call_ext spec_sigma (_id EXTFN_ext_uart_read) arg *)
(*     ; SimPreStepSM__sim_uart_write: *)
(*       forall arg, unsafe_get_field (dstruct_fields enclave_req) FLD_enclave_req__ext_uart *)
(*                 (unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__data *)
(*                    spec_st.[_id (SM.lookup_reg_enc_data core)]) = Ob~1 -> *)
(*               unsafe_call_ext impl_sigma (_id EXTFN_ext_uart_write) arg = unsafe_call_ext spec_sigma (_id EXTFN_ext_uart_write) arg *)

(*     }. *)

(*   Record PostStepCommon (st st': koika_state_t) (ext: ext_log_t) *)
(*                     : Prop := *)
(*     { PostStepSM__ext_push: SortedExtFnEnv.opt_get ext (snd EXTFN_ext_mem_push_request) = None *)
(*     }. *)

(*   Record PostStepSMImpl (st st': koika_state_t) (ext: ext_log_t) : Prop := *)
(*     { PostStepSMImpl__Common: PostStepCommon st st' ext *)
(*     ; PostStepSMImpl__no_write: forall reg, (In reg (map _id (sm0_regs ++ sm1_regs)) -> False) -> *)
(*                                        st.[reg] = st'.[reg] *)
(*     ; PostStepSMImpl__config_same0: *)
(*         unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__valid *)
(*                            st.[_id (SM.lookup_reg_enc_data CoreId0)] = Ob~1 -> *)
(*         unsafe_get_field (dstruct_fields enclave_data) FLD_enclave_data__valid *)
(*                            st'.[_id (SM.lookup_reg_enc_data CoreId0)] = Ob~1 -> *)
(*         st.[_id (SM.lookup_reg_enc_data CoreId0)] = st'.[_id (SM.lookup_reg_enc_data CoreId0)] /\ *)
(*         st'.[_id (SM.lookup_reg_state CoreId0)] <> ENUM_core_state__WAITING *)
(*     }. *)

(*   Record PostStepSMSpec (core: ind_core_id) (st st': koika_state_t) (ext: ext_log_t) *)
(*                         : Prop := *)
(*     { PostStepSMSpec__Common: PostStepCommon st st' ext *)
(*     ; PostStepSMSpec__no_write: *)
(*           forall reg, (In reg (map _id (sm0_regs ++ sm1_regs)) -> False) -> *)
(*                  st.[reg] = st'.[reg] *)
(*     }. *)

(*   (* forall regs, In reg reg_list -> impl_st.[reg] = spec_st.[reg]. *) *)
(*   (* TODO: mem reqs in range *) *)
(*   (* TODO: disjoint configs; impl addr in range for other core *) *)
(*   Record SimPostStepSM (core: ind_core_id) *)
(*                        impl_st (impl_sigma: @ext_sigma_t N) (impl_st': koika_state_t) (impl_ext: ext_log_t) *)
(*                        spec_st (spec_sigma: @ext_sigma_t N) (spec_st': koika_state_t) (spec_ext: ext_log_t) *)
(*                        (init_config: enclave_config) *)
(*                         : Prop := *)
(*   { SimPostStepSM__impl: PostStepSMImpl impl_st impl_st' impl_ext; *)
(*     SimPostStepSM__spec: PostStepSMSpec core spec_st spec_st' spec_ext; *)
(*     SimPostStepSM__led: config_ext_led init_config  = true -> *)
(*                       unsafe_get_ext_call_from_log impl_ext EXTFN_ext_led = *)
(*                       unsafe_get_ext_call_from_log spec_ext EXTFN_ext_led; *)
(*     SimPostStepSM__uart_read: config_ext_uart init_config = true -> *)
(*                       unsafe_get_ext_call_from_log impl_ext EXTFN_ext_uart_read = *)
(*                       unsafe_get_ext_call_from_log spec_ext EXTFN_ext_uart_read; *)
(*     SimPostStepSM__uart_write: config_ext_uart init_config = true -> *)
(*                       unsafe_get_ext_call_from_log impl_ext EXTFN_ext_uart_write = *)
(*                       unsafe_get_ext_call_from_log spec_ext EXTFN_ext_uart_write; *)
(*     SimPostStepSM__invariant: SimInvariant core impl_st' spec_st' init_config *)
(*   }. *)

(*   Definition foo_mmio_req_in_range *)
(*     (core: ind_core_id) (reg_fn: reg_t -> sval) (get_field: debug_id_ty -> debug_id_ty -> sval -> sval): fancy_spred := *)
(*     let (to_mmio_data, to_mmio_valid) := *)
(*       match core with *)
(*       | CoreId0 => (SM.toMMIO0.REG_data0, SM.toMMIO0.REG_valid0) *)
(*       | CoreId1 => (SM.toMMIO1.REG_data0, SM.toMMIO1.REG_valid0) *)
(*       end in *)
(*      let sval_enclave_data := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__data (reg_fn (SM.lookup_reg_enc_data core))  in *)
(*      let sval_enclave_valid := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__valid (reg_fn (SM.lookup_reg_enc_data core))  in *)
(*     {{{ `sval_enclave_valid` = Ob~1 -> *)
(*         `reg_fn to_mmio_valid` = Ob~1 -> *)
(*         { `get_field mem_req.(sid) FLD_mem_req__addr (reg_fn to_mmio_data)` = #MMIO_UART_ADDRESS -> *)
(*           `get_field enclave_req.(sid) FLD_enclave_req__ext_uart sval_enclave_data ` = Ob~1 *)
(*         } /\ *)
(*         { `get_field mem_req.(sid) FLD_mem_req__addr (reg_fn to_mmio_data)` = #MMIO_LED_ADDRESS -> *)
(*           `get_field enclave_req.(sid) FLD_enclave_req__ext_led sval_enclave_data ` = Ob~1 *)
(*         } *)
(*     }}}. *)

(*   Definition foo_other_mmio_req_empty *)
(*     (core: ind_core_id) reg_fn  : fancy_spred := *)
(*     let other_to_mmio_valid := *)
(*       match core with *)
(*       | CoreId0 => SM.toMMIO1.REG_valid0 *)
(*       | CoreId1 => SM.toMMIO0.REG_valid0 *)
(*       end in *)
(*     {{{ `reg_fn other_to_mmio_valid` = Ob~0 }}}. *)

(*   Definition foo_disjoint_configs (reg_fn: reg_t -> sval) (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) : fancy_spred := *)
(*      let sval_enclave_data0 := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__data (reg_fn (SM.lookup_reg_enc_data CoreId0))  in *)
(*      let sval_enclave_data1 := *)
(*        get_field enclave_data.(sid) FLD_enclave_data__data (reg_fn (SM.lookup_reg_enc_data CoreId1))  in *)
(*      {{{ { `get_field enclave_req.(sid) FLD_enclave_req__ext_led sval_enclave_data0` = Ob~0 \/ *)
(*                `get_field enclave_req.(sid) FLD_enclave_req__ext_led sval_enclave_data1` = Ob~0} /\ *)
(*         { `get_field enclave_req.(sid) FLD_enclave_req__ext_uart sval_enclave_data0` = Ob~0 \/ *)
(*                `get_field enclave_req.(sid) FLD_enclave_req__ext_uart sval_enclave_data1` = Ob~0} *)
(*      }}}. *)

(*   Definition foo_ImplInvariant (impl_reg_fn: reg_t -> sval) := *)
(*    [ (Custom_ImplInvariant__mmio_req_in_range0, foo_mmio_req_in_range CoreId0 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__mmio_req_in_range1, foo_mmio_req_in_range CoreId1 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__disjoint_configs, foo_disjoint_configs impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__disjoint_eid, foo_disjoint_eid impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__disjoint_sid, foo_disjoint_sid impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__reset0, foo_reset_correct CoreId0 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__reset1, foo_reset_correct CoreId1 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__reset_mem0, foo_reset_mem_correct CoreId0 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__reset_mem1, foo_reset_mem_correct CoreId1 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__running_inv0, foo_running_inv CoreId0 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__running_inv1, foo_running_inv CoreId1 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__enc_req0, foo_enc_req CoreId0 impl_reg_fn impl_get_field) *)
(*    ; (Custom_ImplInvariant__enc_req1, foo_enc_req CoreId1 impl_reg_fn impl_get_field) *)
(*    ]. *)
(*   Definition foo_fifo_req_addrs_not_in_range enclave_sig (reg_fn: reg_t -> sval)  (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) (reg_valid reg_data reg_enclave: reg_t) *)
(*               : fancy_spred := *)
(*     let reg_data := reg_fn reg_data in *)
(*     let reg_enclave := reg_fn reg_enclave in *)
(*     {{{ `reg_fn reg_valid` = Ob~1 -> *)
(*         { *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Enclave Enclave0) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Enclave Enclave1) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Enclave Enclave2) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Enclave Enclave3) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Shared Shared01) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Shared Shared02) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Shared Shared03) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Shared Shared12) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Shared Shared13) get_field reg_data reg_enclave`` \/ *)
(*         ``foo_req_addrs_in_region enclave_sig (MemRegion_Shared Shared23) get_field reg_data reg_enclave``} -> *)
(*         False *)
(*     }}}. *)

(*   Definition foo_other_req_addrs_not_in_range (core: ind_core_id) *)
(*                                         (reg_fn: reg_t -> sval) *)
(*                                         (get_field : debug_id_ty -> debug_id_ty -> sval -> sval) *)
(*                                         : fancy_spred := *)
(*     let (to_imem_data, to_imem_valid) := *)
(*       match other_core core with *)
(*       | CoreId0 => (SM.Memory.toIMem0.REG_data0, SM.Memory.toIMem0.REG_valid0) *)
(*       | CoreId1 => (SM.Memory.toIMem1.REG_data0, SM.Memory.toIMem1.REG_valid0) *)
(*       end in *)
(*     let (to_dmem_data, to_dmem_valid) := *)
(*       match other_core core with *)
(*       | CoreId0 => (SM.Memory.toDMem0.REG_data0, SM.Memory.toDMem0.REG_valid0) *)
(*       | CoreId1 => (SM.Memory.toDMem1.REG_data0, SM.Memory.toDMem1.REG_valid0) *)
(*       end in *)
(*     {{{ `senc_data_valid core reg_fn get_field` = Ob~1 -> *)
(*         { ``foo_fifo_req_addrs_not_in_range EnclaveParams.enclave_sig reg_fn get_field to_imem_valid to_imem_data (SM.lookup_reg_enc_data core) `` /\ *)
(*         ``foo_fifo_req_addrs_not_in_range EnclaveParams.enclave_sig reg_fn get_field to_dmem_valid to_dmem_data (SM.lookup_reg_enc_data core) `` } *)
(*     }}}. *)

(*   Definition foo_SimInvariant (core: ind_core_id) (impl_reg_fn: reg_t -> sval) (spec_reg_fn: reg_t -> sval) := *)
(*     [(Custom_SimInvariant__reg_sim, {{{ forall x in (sm_regs core), `impl_reg_fn x` = `spec_reg_fn x` }}}) *)
(*     ;(Custom_SimInvariant__valid_addrs_impl, foo_req_addrs_in_range core impl_reg_fn impl_get_field) *)
(*     ;(Custom_SimInvariant__valid_addrs_impl_other, *)
(*        foo_other_req_addrs_not_in_range core impl_reg_fn impl_get_field) *)
(*     ;(Custom_SimInvariant__valid_addrs_spec, foo_req_addrs_in_range core spec_reg_fn spec_get_field) *)
(*     ; (Custom_SimInvariant__other_mmio_empty, foo_other_mmio_req_empty core spec_reg_fn) *)
(*     ]. *)

(*   Definition foo_SimPreStepSM (core: ind_core_id) := *)
(*     ([(Custom_SimPreStepSM__running, {{{ impl0.[(SM.lookup_reg_state core)] <> #ENUM_core_state__WAITING }}} ) *)
(*      ;(Custom_SimPreStepSM__valid, {{{ `impl_get_field enclave_data.(sid) FLD_enclave_data__valid (impl_init (SM.lookup_reg_enc_data core))` = Ob~1 }}}) *)
(*      ; (Custom_SimPreStepSM__led, {{{ *)
(*                forall1 "arg" of (unsafe_get_ext_fn_arg_type EXTFN_ext_led), *)
(*                `spec_get_field enclave_req.(sid) FLD_enclave_req__ext_led *)
(*                            (spec_get_field enclave_data.(sid) FLD_enclave_data__data (spec_init (SM.lookup_reg_enc_data core)))` = Ob~1 -> *)
(*            `impl_ext_app EXTFN_ext_led (SBound "arg")` = `spec_ext_app EXTFN_ext_led (SBound "arg")` *)
(*        }}}) *)
(*      ; (Custom_SimPreStepSM__uart_read, {{{ *)
(*                forall1 "arg" of (unsafe_get_ext_fn_arg_type EXTFN_ext_uart_read), *)
(*                `spec_get_field enclave_req.(sid) FLD_enclave_req__ext_uart *)
(*                            (spec_get_field enclave_data.(sid) FLD_enclave_data__data (spec_init (SM.lookup_reg_enc_data core)))` = Ob~1 -> *)
(*            `impl_ext_app EXTFN_ext_uart_read (SBound "arg")` = `spec_ext_app EXTFN_ext_uart_read (SBound "arg")` *)
(*        }}}) *)
(*      ; (Custom_SimPreStepSM__uart_write, {{{ *)
(*                forall1 "arg" of (unsafe_get_ext_fn_arg_type EXTFN_ext_uart_write), *)
(*                `spec_get_field enclave_req.(sid) FLD_enclave_req__ext_uart *)
(*                            (spec_get_field enclave_data.(sid) FLD_enclave_data__data (spec_init (SM.lookup_reg_enc_data core)))` = Ob~1 -> *)
(*            `impl_ext_app EXTFN_ext_uart_write (SBound "arg")` = `spec_ext_app EXTFN_ext_uart_write (SBound "arg")` *)
(*        }}}) *)
(*      ] ++ (foo_SimInvariant core impl_init spec_init) ++ (foo_ImplInvariant impl_init))%list. *)


(*   Definition foo_SimPostStepSM (core: ind_core_id) := *)
(*     ([(Custom_PostStepSM__config_same0, *)
(*        {{{ `impl_get_field enclave_data.(sid) FLD_enclave_data__valid (impl_init (SM.lookup_reg_enc_data CoreId0))` = Ob~1  -> *)
(*            `impl_get_field enclave_data.(sid) FLD_enclave_data__valid (impl_final (SM.lookup_reg_enc_data CoreId0))` = Ob~1  -> *)
(*            impl0.[(SM.lookup_reg_enc_data CoreId0)] = impl1.[SM.lookup_reg_enc_data CoreId0] /\ *)
(*            impl1.[(SM.lookup_reg_state core)] <> #ENUM_core_state__WAITING *)
(*        }}}) *)
(*     ;(Custom_SimPostStepSM__led, *)
(*        {{{ `impl_get_field enclave_req.(sid) FLD_enclave_req__ext_led *)
(*                            (impl_get_field enclave_data.(sid) FLD_enclave_data__data (impl_init (SM.lookup_reg_enc_data core)))` = Ob~1 -> *)
(*            impl_ext1.[EXTFN_ext_led] = spec_ext1.[EXTFN_ext_led] *)
(*        }}}) *)
(*     ;(Custom_SimPostStepSM__uart_read, *)
(*        {{{ `impl_get_field enclave_req.(sid) FLD_enclave_req__ext_uart *)
(*                            (impl_get_field enclave_data.(sid) FLD_enclave_data__data (impl_init (SM.lookup_reg_enc_data core)))` = Ob~1 -> *)
(*            impl_ext1.[EXTFN_ext_uart_read] = spec_ext1.[EXTFN_ext_uart_read] *)
(*       }}}) *)
(*     ;(Custom_SimPostStepSM__uart_write, *)
(*        {{{ `impl_get_field enclave_req.(sid) FLD_enclave_req__ext_uart *)
(*                           (impl_get_field enclave_data.(sid) FLD_enclave_data__data (impl_init (SM.lookup_reg_enc_data core)))` = Ob~1 -> *)
(*            impl_ext1.[EXTFN_ext_uart_write] = spec_ext1.[EXTFN_ext_uart_write] *)
(*        }}}) *)
(*     ;(Custom_SimPostStepSM__config_preserved, *)
(*         {{{ `senc_data_valid core impl_init impl_get_field` = Ob~1  -> *)
(*             `senc_data_valid core impl_final impl_get_field` = Ob~1  -> *)
(*             `impl_init (SM.lookup_reg_enc_data core)` = `impl_final (SM.lookup_reg_enc_data core)` *)
(*         }}} *)
(*      ) *)
(*     ] ++ (foo_SimInvariant core impl_final spec_final) ++ (foo_ImplInvariant impl_final) )%list. *)


(*   Lemma SimPreStepSm_preserved: *)
(*     forall core impl_st spec_st config impl_st' spec_st'  impl_sigma spec_sigma, *)
(*     SimPreStepSM core impl_st spec_st impl_sigma spec_sigma config -> *)
(*     (forall reg, In reg (private_sm0_regs ++ private_sm1_regs) -> *)
(*                     impl_st.[_id reg] = impl_st'.[_id reg]) -> *)
(*     (forall reg, In reg (private_sm0_regs ++ private_sm1_regs) -> *)
(*                     spec_st.[_id reg] = spec_st'.[_id reg]) -> *)
(*     (forall reg, In reg (sm_regs core) -> *)
(*             impl_st'.[_id reg] = spec_st'.[_id reg]) -> *)
(*     req_addrs_in_range core impl_st' config -> *)
(*     req_addrs_in_range core spec_st' config -> *)
(*     req_addrs_not_in_range (other_core core) impl_st' config -> *)
(*     (forall core, impl_interp_spred_with_init_st_only impl_st' *)
(*       (foo_reset_mem_correct core impl_init impl_get_field)) -> *)
(*     (impl_st.[_id SM.Memory.REG_purge0] = ENUM_purge_state__READY \/ impl_st.[_id SM.Memory.REG_purge0] = ENUM_purge_state__PURGED -> *)
(*      impl_st'.[_id SM.Memory.REG_purge0] = impl_st.[_id SM.Memory.REG_purge0]) -> *)
(*     (impl_st.[_id SM.Memory.REG_purge1] = ENUM_purge_state__READY \/ impl_st.[_id SM.Memory.REG_purge1] = ENUM_purge_state__PURGED -> *)
(*      impl_st'.[_id SM.Memory.REG_purge1] = impl_st.[_id SM.Memory.REG_purge1]) -> *)
(*     SimPreStepSM core impl_st' spec_st' impl_sigma spec_sigma config. *)
(*   Proof. *)
(*     intros * hpre himpl_sim hspec_sim hsim himpl_valid hspec_valid himpl_other hreset_mem *)
(*              hmem0_purge hmem1_purge (* hcore0_purge hcore1_purge *). *)
(*     destruct hpre. *)
(*     constructor. *)
(*     - destruct SimPreStepSM__Invariant0. constructor; auto. *)
(*       + destruct core; rewrite<-hspec_sim; auto; solve_In_to_find. *)
(*       + destruct SimInvariant__ImplInvariant0. *)
(*         constructor. *)
(*         * unfold mmio_req_in_range; unfold enc_data_valid. destruct core; repeat rewrite<-himpl_sim; auto; solve_In_to_find. *)
(*         * unfold mmio_req_in_range; unfold enc_data_valid. destruct core; repeat rewrite<-himpl_sim; auto; solve_In_to_find. *)
(*         * cbn - [_id]. repeat rewrite<-himpl_sim by solve_In_to_find. auto. *)
(*         * cbn - [_id]. repeat rewrite<-himpl_sim by solve_In_to_find. auto. *)
(*         * repeat rewrite<-himpl_sim; auto; destruct core; auto; try solve_In_to_find. *)
(*         * cbn - [_id]; repeat rewrite<-himpl_sim by (solve_In_to_find); eauto. *)
(*           cbn - [_id] in ImplInvariant__reset_correct2. *)
(*           propositional. split_ands_in_goal; auto. *)
(*           { intro. propositional. rewrite hmem0_purge; eauto. } *)
(*           { rewrite<-himpl_sim by solve_In_to_find. auto. } *)
(*           { rewrite<-himpl_sim by solve_In_to_find. auto. } *)
(*         * cbn - [_id]; repeat rewrite<-himpl_sim by (solve_In_to_find); eauto. *)
(*           cbn - [_id] in ImplInvariant__reset_correct3. *)
(*           propositional. split_ands_in_goal; auto. *)
(*           { intro. propositional. rewrite hmem1_purge; eauto. } *)
(*           { rewrite<-himpl_sim by solve_In_to_find. auto. } *)
(*           { rewrite<-himpl_sim by solve_In_to_find. auto. } *)
(*         * auto. *)
(*         * auto. *)
(*         * cbn - [_id]. repeat rewrite<-himpl_sim by (solve_In_to_find). *)
(*           intros. apply ImplInvariant__running_inv2 in H. cbn - [_id] in H. propositional. *)
(*           rewrite hmem0_purge by eauto. auto. *)
(*         * cbn - [_id]. repeat rewrite<-himpl_sim by (solve_In_to_find). *)
(*           intros. apply ImplInvariant__running_inv3 in H. cbn - [_id] in H. propositional. *)
(*           rewrite hmem1_purge by eauto. auto. *)
(*         * cbn - [_id]; repeat rewrite<-himpl_sim by (solve_In_to_find); auto. *)
(*         * cbn - [_id]; repeat rewrite<-himpl_sim by (solve_In_to_find); auto. *)
(*     - rewrite<-himpl_sim; auto. destruct core; auto; solve_In_to_find. *)
(*     - rewrite<-himpl_sim; auto. destruct core; auto; solve_In_to_find. *)
(*     - rewrite<-himpl_sim; auto. destruct core; auto; solve_In_to_find. *)
(*     - intro. rewrite<-hspec_sim; auto. destruct core; auto; solve_In_to_find. *)
(*     - intro. rewrite<-hspec_sim; auto. destruct core; auto; solve_In_to_find. *)
(*     - intro. rewrite<-hspec_sim; auto. destruct core; auto; solve_In_to_find. *)
(*   Qed. *)
(*   Definition SimPreStepSM' (core: ind_core_id) *)
(*                        impl_st (impl_sigma: @ext_sigma_t N) (impl_st': koika_state_t) (impl_ext: ext_log_t) *)
(*                        spec_st (spec_sigma: @ext_sigma_t N) (spec_st': koika_state_t) (spec_ext: ext_log_t) *)
(*                        (config: enclave_config) := *)
(*     let impl_pkg := {| pkg_machine := impl_machine; *)
(*                        pkg_init_st := impl_st; *)
(*                        pkg_sigma := impl_sigma; *)
(*                        pkg_mid_st := None; *)
(*                        pkg_final_st := impl_st'; *)
(*                        pkg_mid_ext_log := None; *)
(*                        pkg_ext_log' := impl_ext |} in *)
(*     let spec_pkg := {| pkg_machine := spec0_machine; *)
(*                        pkg_init_st := spec_st; *)
(*                        pkg_sigma := spec_sigma; *)
(*                        pkg_mid_st := None; *)
(*                        pkg_final_st := spec_st'; *)
(*                        pkg_mid_ext_log := None; *)
(*                        pkg_ext_log' := spec_ext |} in *)
(*     unsafe_enclave_data_to_config (impl_st.[_id (SM.lookup_reg_enc_data core)]) = config /\ *)
(*     Forall (fun '(_, p) => interp_fancy_spred2 impl_pkg spec_pkg p) (foo_SimPreStepSM core). *)
(*   Definition SimPostStepSM' (core: ind_core_id) *)
(*                        impl_st (impl_sigma: @ext_sigma_t N) (impl_st': koika_state_t) (impl_ext: ext_log_t) *)
(*                        spec_st (spec_sigma: @ext_sigma_t N) (spec_st': koika_state_t) (spec_ext: ext_log_t) *)
(*                        (init_config: enclave_config) := *)
(*     let impl_pkg := {| pkg_machine := impl_machine; *)
(*                        pkg_init_st := impl_st; *)
(*                        pkg_sigma := impl_sigma; *)
(*                        pkg_mid_st := None; *)
(*                        pkg_final_st := impl_st'; *)
(*                        pkg_mid_ext_log := None; *)
(*                        pkg_ext_log' := impl_ext |} in *)
(*     let spec_pkg := {| pkg_machine := spec0_machine; *)
(*                        pkg_init_st := spec_st; *)
(*                        pkg_sigma := spec_sigma; *)
(*                        pkg_mid_st := None; *)
(*                        pkg_final_st := spec_st'; *)
(*                        pkg_mid_ext_log := None; *)
(*                        pkg_ext_log' := spec_ext |} in *)
(*     (forall reg, (In reg (map _id (sm0_regs ++ sm1_regs)) -> False) -> *)
(*              impl_st.[reg] = impl_st'.[reg]) /\ *)
(*     (forall reg, (In reg (map _id (sm0_regs ++ sm1_regs)) -> False) -> *)
(*              spec_st.[reg] = spec_st'.[reg]) /\ *)
(*     (SortedExtFnEnv.opt_get impl_ext (snd EXTFN_ext_mem_push_request) = None) /\ *)
(*     (SortedExtFnEnv.opt_get spec_ext (snd EXTFN_ext_mem_push_request) = None) /\ *)
(*     Forall (fun '(_, p) => interp_fancy_spred2 impl_pkg spec_pkg p) (foo_SimPostStepSM core). *)
(* (* [Rl_FilterReqs0; Rl_FilterReqs1; Rl_ForwardResps0; Rl_ForwardResps1; Rl_DoMMIO; Rl_UpdateEnclave0; *) *)
(* (*  Rl_UpdateEnclave1; Rl_EnterEnclave0; Rl_EnterEnclave1; Rl_ExitEnclave0; Rl_ExitEnclave1; Rl_DoClk] *) *)
(*   Lemma schedule_oraat_ok: *)
(*     oraat_ok SM._int_fns (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl)) *)
(*               (list_of_schedule SM.schedule) = true. *)
(*   Proof. *)
(*     vm_compute. reflexivity. *)
(*   Qed. *)
(*   Lemma schedule_oraat_ok_spec0: *)
(*     oraat_ok SM._int_fns (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl)) *)
(*               (list_of_schedule Implementation.Core0Machine.sm0_schedule) = true. *)
(*   Proof. *)
(*     vm_compute. reflexivity. *)
(*   Qed. *)

(*   Parameter smt_sim0_correct: *)
(*     symbolic_evaluate_file_success_product *)
(*       impl_machine spec0_machine impl_schedule spec0_schedule *)
(*         (map (fun '(_, p) => (unfancy p)) (foo_SimPreStepSM CoreId0)) *)
(*         (map (fun '(_, p) => (unfancy p)) (foo_SimPostStepSM CoreId0)). *)
(*   Lemma TEST_interp_sm_sim0: *)
(*    sim_interp_scheduler_satisfies_spec *)
(*      Machine.SM.reg_type_env _ext_fn_tys *)
(*      SM._int_fns SM._int_fns *)
(*      SM._struct_defs SM._struct_defs *)
(*      (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl)) *)
(*      (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl)) *)
(*      SM.schedule Implementation.Core0Machine.sm0_schedule enclave_config *)
(*      (fun impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost => *)
(*         SimPreStepSM' CoreId0 *)
(*           impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost ) *)
(*      (SimPostStepSM' CoreId0). *)
(*   Proof. *)
(*     unfold sim_interp_scheduler_satisfies_spec. *)
(*     intros * hwf_impl hwf_spec hwf_impl_sigma hwf_spec_sigma hwf_impl_fns hwf_spec_fns *)
(*              himpl_step hspec_step hpre. *)
(*     specialize typecheck_scheduler_correct'' with (5 := himpl_step) (2 := hwf_impl) (3 := hwf_impl_sigma) (4 := hwf_impl_fns) (1 := eq_refl). intros (hwf_impl' & wf_impl_ext'). *)
(*     specialize typecheck_scheduler_correct'' with (5 := hspec_step) (2 := hwf_spec) (3 := hwf_spec_sigma) (4 := hwf_spec_fns) (1 := eq_refl). intros (hwf_spec' & wf_spec_ext'). *)
(*     split_ands_in_goal; auto. *)
(*     unfold SimPostStepSM'. *)
(*     unfold SimPreStepSM' in *. propositional. *)

(*     assert(  SortedExtFnEnv.opt_get (Log__ext impl_log) (snd EXTFN_ext_mem_push_request) = None) as himpl_ext_mem. *)
(*     { eapply ext_fn_taint_schedule_empty_correct_fn with (2 := himpl_step). vm_compute. reflexivity. } *)
(*     assert(  SortedExtFnEnv.opt_get (Log__ext spec_log) (snd EXTFN_ext_mem_push_request) = None) as hspec_ext_mem. *)
(*     { eapply ext_fn_taint_schedule_empty_correct_fn with (2 := hspec_step). vm_compute. reflexivity. } *)
(*     eapply oraat_interp_scheduler__conflicts_correct with *)
(*       (1 := strong_WF_state_weaken _ _ hwf_impl) *)
(*       (5 := schedule_oraat_ok) in himpl_step; eauto. *)
(*     eapply oraat_interp_scheduler__conflicts_correct with *)
(*       (1 := strong_WF_state_weaken _ _ hwf_spec) *)
(*       (5 := schedule_oraat_ok_spec0) in hspec_step; eauto. *)

(*     split_ands_in_goal; auto. *)
(*     - eapply taint_safety_schedule in himpl_step; [ | vm_compute; reflexivity]. *)
(*       intros. symmetry. *)
(*       specialize (check_regs_outside_reg_set_untainted_correct) with *)
(*         (int_fns := SM._int_fns) *)
(*         (rules := (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl))) *)
(*         (schedule := SM.schedule) (regs := (map _id (sm0_regs ++ sm1_regs)%list)) (1 := eq_refl). *)
(*       intros (env & htaint & hin). *)
(*       eapply taint_set_to_prop_no_write'. *)
(*       2: { eapply forall_regs_no_writes_exclude. eapply hin. apply H. } *)
(*       rewrite<-htaint. apply himpl_step. *)
(*     - eapply taint_safety_schedule in hspec_step; [ | vm_compute; reflexivity]. *)
(*       intros. symmetry. *)
(*       specialize (check_regs_outside_reg_set_untainted_correct) with *)
(*         (int_fns := SM._int_fns) *)
(*         (rules := (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl))) *)
(*         (schedule := Core0Machine.sm0_schedule) (regs := (map _id (sm0_regs ++ sm1_regs)%list)) (1 := eq_refl). *)
(*       intros (env & htaint & hin). *)
(*       eapply taint_set_to_prop_no_write'. *)
(*       2: { eapply forall_regs_no_writes_exclude. eapply hin. apply H. } *)
(*       rewrite<-htaint. apply hspec_step. *)
(*     - rewrite<-Forall_interp_fancy2_rewrite. *)
(*       apply smt_sim0_correct. *)
(*       + rewrite Forall_interp_fancy2_rewrite. auto. *)
(*       + unfold machine_to_prop. split_ands_in_goal. *)
(*         * auto. *)
(*         * apply strong_WF_state_weaken in hwf_impl. auto. *)
(*         * rewrite<-himpl_step. rewrite<-oraat_interp_scheduler_list_iff. *)
(*           symmetry. eapply oraat_interp_scheduler_list_expand. *)
(*           replace (list_of_schedule SM.schedule) with (map fst (impl_schedule_list)) by reflexivity. *)
(*           apply @Forall2_rules_equiv_preprocess. vm_compute. reflexivity. *)
(*       + unfold machine_to_prop. split_ands_in_goal. *)
(*         * auto. *)
(*         * apply strong_WF_state_weaken in hwf_spec. auto. *)
(*         * rewrite<-hspec_step. rewrite<-oraat_interp_scheduler_list_iff. *)
(*           symmetry. eapply oraat_interp_scheduler_list_expand. *)
(*           replace (list_of_schedule Core0Machine.sm0_schedule) with (map fst (spec0_schedule_list)) by reflexivity. *)
(*           apply @Forall2_rules_equiv_preprocess. vm_compute. reflexivity. *)
(*   Qed. *)

(* Lemma enclave_eid: *)
(*   forall eid data, *)
(*   Datatypes.length data = struct_sz enclave_data -> *)
(*   unsafe_get_field (unsafe_lookup_dstruct_fields SM.struct_defs enclave_req_id) *)
(*     FLD_enclave_req__eid *)
(*     (unsafe_get_field (unsafe_lookup_dstruct_fields SM.struct_defs enclave_data_id) *)
(*                FLD_enclave_data__data data) = enclave_id_to_vect eid <-> *)
(*   eid = config_eid (unsafe_enclave_data_to_config data). *)
(* Proof. *)
(*   intros * hlen. destruct eid; simpl; auto. *)
(*   all: unfold unsafe_lookup_dstruct_fields; simpl; split; auto; *)
(*     [ intros H; rewrite H; auto | intros H; consider unsafe_enclave_id_vect_to_eid; *)
(*                                   bash_destruct H; simplify; auto]. *)
(*   pose proof (eta_expand_list_correct false data) as hdata. rewrite hlen in hdata. *)
(*   cbn in hdata. rewrite hdata in *. cbn in *. *)
(*   destruct_with_eqn (nth 0 data false); destruct_with_eqn (nth 1 data false); auto. *)
(* Qed. *)
(* Lemma shared_region_lookup: *)
(*   forall data sid, *)
(*   Datatypes.length data = struct_sz enclave_data -> *)
(*   success_or_default *)
(*     (let/res b *)
(*      := sel (unsafe_get_field (unsafe_lookup_dstruct_fields SM.struct_defs enclave_req_id) *)
(*              FLD_enclave_req__shared_regions *)
(*              (unsafe_get_field *)
(*                 (unsafe_lookup_dstruct_fields SM.struct_defs enclave_data_id) *)
(*                 FLD_enclave_data__data data)) *)
(*             (shared_id_index sid) in Success [b]) [] = [true] <-> *)
(*   config_shared_regions (unsafe_enclave_data_to_config data) sid = true. *)
(* Proof. *)
(*   intros * hlen. *)
(*   pose proof (eta_expand_list_correct false data) as hdata. rewrite hlen in hdata. *)
(*   cbn in hdata. rewrite hdata. unfold sel. unfold __debug__. *)
(*   unfold unsafe_lookup_dstruct_fields. *)
(*   cbn - [to_nat to_N]. *)
(*   destruct sid; cbn; simpl; apply unit_equiv. *)
(* Qed. *)
(* Ltac config_req_addrs_in_range_simplify:= *)
(*   match goal with *)
(*   | _ => progress (simplify; safe_propositional; try rewrite_solve) *)
(*   | H: _ && _ = true |- _ => *)
(*       rewrite andb_true_iff in H *)
(*   | H: (_ <=? _)%N = true |- _ => *)
(*       rewrite N.leb_le in H *)
(*   | H: (_ <? _)%N = true |- _ => *)
(*       rewrite N.ltb_lt in H *)
(*   | |- _ && _ = true => *)
(*       rewrite andb_true_iff; split *)
(*   | |- (_ <=? _)%N = true => *)
(*       rewrite N.leb_le *)
(*   | |- (_ <? _)%N = true => *)
(*       rewrite N.ltb_lt *)
(*   | |- beq_dec _ _ = true => *)
(*       rewrite beq_dec_iff *)
(*   | H: (_ ?= _)%N = Gt |- _ => rewrite N.compare_gt_iff in H *)
(*   | H: (_ ?= _)%N = Eq |- _ => rewrite N.compare_eq_iff in H *)
(*   | |- context[Datatypes.length (firstn_fill _ _ _)] => rewrite firstn_fill_length *)
(*   | H: ?_eid = config_eid _ |- *)
(*     unsafe_get_field _ FLD_enclave_req__eid _ = _ => *)
(*     rewrite enclave_eid with (eid := _eid) *)
(*   | |- success_or_default (bitfun_of_predicate unsigned_le _ _) [] = [true] => *)
(*     eapply bitfun_unsigned_le_iff; auto *)
(*   | |- (_ <= to_N _)%N => *)
(*     eapply bitfun_unsigned_le_iff; auto *)
(*   | |- context[Datatypes.length (_enclave_base EnclaveParams.enclave_sig _)] => *)
(*     rewrite wf_enclave_base with (1 := EnclaveParams.wf_sig) *)
(*   | |- context[Datatypes.length (_enclave_size EnclaveParams.enclave_sig _)] => *)
(*     rewrite wf_enclave_size with (1 := EnclaveParams.wf_sig) *)
(*   | |- context[Datatypes.length (_shared_region_base EnclaveParams.enclave_sig _)] => *)
(*     rewrite wf_shared_base with (1 := EnclaveParams.wf_sig) *)
(*   | |- context[Datatypes.length (_shared_region_size EnclaveParams.enclave_sig )] => *)
(*     rewrite wf_shared_size with (1 := EnclaveParams.wf_sig) *)
(*   | H: config_shared_regions _ ?_sid = true *)
(*   |-  success_or_default (let/res b := sel _ _ in Success [b])  [] = [true] => *)
(*     eapply shared_region_lookup with (sid := _sid) *)
(*   | |- success_or_default (bitfun_of_predicate unsigned_lt _ (success_or_default (plus _ _) [])) [] = [true] => *)
(*     eapply bitfun_unsigned_lt_plus *)
(*   | |- (_ < _ )%N => *)
(*     eapply bitfun_unsigned_lt_plus; auto *)
(*   | H: unsafe_get_field _ FLD_enclave_req__eid _ = _ *)
(*   |- _ = config_eid (unsafe_enclave_data_to_config _) => *)
(*     eapply enclave_eid; eauto *)
(*   | |- config_shared_regions (unsafe_enclave_data_to_config _) _ = true => *)
(*     eapply shared_region_lookup; eauto *)
(*   end. *)

(*   Lemma config_fifo_addrs_in_range_iff: *)
(*     forall st config reg_valid reg_data reg_enclave reg_fn pkg, *)
(*     (* WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) st -> *) *)
(*     Datatypes.length st.[_id reg_enclave] = struct_sz enclave_data -> *)
(*     Datatypes.length st.[_id reg_data] = struct_sz mem_req -> *)
(*     Datatypes.length st.[_id reg_valid] = 1 -> *)
(*     unsafe_enclave_data_to_config st.[_id reg_enclave] = config -> *)
(*     reg_fn = impl_init /\ st = pkg_init_st pkg \/ *)
(*     reg_fn = impl_final /\ st = pkg_final_st pkg -> *)
(*     pkg.(pkg_machine).(file_struct_defs) = SM.struct_defs -> *)
(*     fifo_addrs_in_range EnclaveParams.enclave_sig st config (_id reg_valid) (_id reg_data) <-> *)
(*       interp_fancy_spred' pkg [] *)
(*      (foo_fifo_req_addrs_in_range EnclaveParams.enclave_sig reg_fn impl_get_field reg_valid *)
(*         reg_data reg_enclave). *)
(*   Proof. *)
(*     intros * henc_len hdata_len hvalid_len hconfig hreg_fn hstructs. *)
(*     unfold fifo_addrs_in_range. *)
(*     assert (forall reg ext, interp_sval pkg ext (reg_fn reg) = st.[_id reg]) as hreg_fn'. *)
(*     { intros. split_cases; auto. } *)
(*     cbn. repeat rewrite hreg_fn'. *)
(*     consider addr_in_config. consider addr_in_region. *)
(*     pose proof (eta_expand_list_correct false st.[_id reg_enclave]) as Hdata. rewrite henc_len in Hdata. *)
(*     pose proof (eta_expand_list_correct false st.[_id reg_data]) as Hreg_data; rewrite hdata_len in Hreg_data. *)
(*     pose proof (eta_expand_list_correct false st.[_id reg_valid]) as Hreg_valid; rewrite hvalid_len in Hreg_valid. *)
(*     cbn in Hdata. cbn in Hreg_data. cbn in Hreg_valid. rewrite hstructs. *)
(*     consider region_in_config. *)
(*     split. *)
(*     - intros; propositional.  destruct region. *)
(*       + destruct eid; [left | right; left | right; right; left| right; right; right; left]; *)
(*           config_req_addrs_in_range_simplify; *)
(*           split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)

(*       + destruct id; do 4 right; *)
(*                      [left *)
(*                      | right; left *)
(*                      | right; right; left *)
(*                      | right; right; right; left *)
(*                      | right; right; right; right; left *)
(*                      | right; right; right; right; right]. *)
(*         all: split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + discriminate. *)
(*     - propositional. *)
(*       destruct H as [heid0 | [heid1 | [heid2 | [ heid3 | hsid ] ] ] ]; propositional. *)
(*       + exists (MemRegion_Enclave Enclave0); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + exists (MemRegion_Enclave Enclave1); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + exists (MemRegion_Enclave Enclave2); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + exists (MemRegion_Enclave Enclave3); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + destruct hsid as [hsid01 | [hsid02 | [hsid03 | [ hsid12 | [ hsid13 | hsid23 ] ] ] ] ]; propositional. *)
(*         * exists (MemRegion_Shared Shared01); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared02); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared03); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared12); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared13); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared23); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*   Qed. *)
(*   Lemma config_req_addrs_in_range_iff: *)
(*     forall core st config pkg reg_fn , *)
(*     WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) st -> *)
(*     WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) pkg.(pkg_init_st) -> *)
(*     enc_data_valid core st = Ob~0 \/ (enc_data_valid core st = Ob~1 -> unsafe_enclave_data_to_config st.[_id (SM.lookup_reg_enc_data core)] = config) -> *)
(*     (reg_fn = impl_init /\ st = pkg.(pkg_init_st)) \/ *)
(*     (reg_fn = impl_final /\ st = pkg.(pkg_final_st)) -> *)
(*     file_struct_defs (pkg_machine pkg) = SM.struct_defs -> *)
(*     req_addrs_in_range core st config <-> *)
(*       interp_fancy_spred pkg (foo_req_addrs_in_range core reg_fn impl_get_field). *)
(*   Proof. *)
(*     intros * hwf_final hwf_init hconfig hcase hstructs. *)
(*     unfold foo_req_addrs_in_range. *)
(*     destruct core; simpl. *)
(*     - unfold interp_fancy_spred. unfold req_addrs_in_range. hnf. *)
(*       rewrite interp_fancy_spred'_PBase. *)
(*       rewrite interp_spred'_PImpl. *)
(*       repeat rewrite interp_spred'_PFancy. *)
(*       consider enc_data_valid. *)
(*       repeat rewrite interp_fancy_spred'_PBase. *)
(*       rewrite interp_spred'_PAnd. *)
(*       repeat rewrite interp_spred'_PFancy. *)
(*       destruct hcase as [hcase| hcase]; propositional. *)
(*       { destruct hconfig. *)
(*         { split; propositional; try congruence. *)
(*           cbn in H1. rewrite hstructs in H1. setoid_rewrite H in H1. discriminate. *)
(*         } *)
(*         split; propositional. *)
(*         - cbn in H1. rewrite hstructs in H1. propositional. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*         - assert_pre_and_specialize H0. *)
(*           { cbn. rewrite hstructs. auto. } *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*                 try apply WF_state_length with (1 := hwf_init); auto. *)
(*       } *)
(*       { destruct hconfig. *)
(*         { split; propositional; try congruence. *)
(*           cbn in H1. rewrite hstructs in H1. setoid_rewrite H in H1. discriminate. *)
(*         } *)
(*         split; propositional. *)
(*         - cbn in H1. rewrite hstructs in H1. propositional. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*         - assert_pre_and_specialize H0. *)
(*           { cbn. rewrite hstructs; auto. } *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*       } *)
(*     - unfold interp_fancy_spred. unfold req_addrs_in_range. hnf. *)
(*       rewrite interp_fancy_spred'_PBase. *)
(*       rewrite interp_spred'_PImpl. *)
(*       repeat rewrite interp_spred'_PFancy. *)
(*       consider enc_data_valid. *)
(*       repeat rewrite interp_fancy_spred'_PBase. *)
(*       rewrite interp_spred'_PAnd. *)
(*       repeat rewrite interp_spred'_PFancy. *)
(*       destruct hcase as [hcase| hcase]; propositional. *)
(*       { destruct hconfig. *)
(*         { split; propositional; try congruence. *)
(*           cbn in H1. rewrite hstructs in H1. setoid_rewrite H in H1. discriminate. *)
(*         } *)
(*         split; propositional. *)
(*         - cbn in H1. rewrite hstructs in H1. propositional. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*         - assert_pre_and_specialize H0. *)
(*           { cbn. rewrite hstructs. auto. } *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*                 try apply WF_state_length with (1 := hwf_init); auto. *)
(*       } *)
(*       { destruct hconfig. *)
(*         { split; propositional; try congruence. *)
(*           cbn in H1. rewrite hstructs in H1. setoid_rewrite H in H1. discriminate. *)
(*         } *)
(*         split; propositional. *)
(*         - cbn in H1. rewrite hstructs in H1. propositional. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*         - assert_pre_and_specialize H0. *)
(*           { cbn. rewrite hstructs; auto. } *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*       } *)
(*   Qed. *)

(*   Lemma config_fifo_addrs_not_in_range_iff: *)
(*     forall st config reg_valid reg_data reg_enclave reg_fn pkg, *)
(*     (* WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) st -> *) *)
(*     Datatypes.length st.[_id reg_enclave] = struct_sz enclave_data -> *)
(*     Datatypes.length st.[_id reg_data] = struct_sz mem_req -> *)
(*     Datatypes.length st.[_id reg_valid] = 1 -> *)
(*     unsafe_enclave_data_to_config st.[_id reg_enclave] = config -> *)
(*     reg_fn = impl_init /\ st = pkg_init_st pkg \/ *)
(*     reg_fn = impl_final /\ st = pkg_final_st pkg -> *)
(*     pkg.(pkg_machine).(file_struct_defs) = SM.struct_defs -> *)
(*     fifo_addrs_not_in_range EnclaveParams.enclave_sig st config (_id reg_valid) (_id reg_data) <-> *)
(*       interp_fancy_spred' pkg [] *)
(*      (foo_fifo_req_addrs_not_in_range EnclaveParams.enclave_sig reg_fn impl_get_field reg_valid *)
(*         reg_data reg_enclave). *)
(*   Proof. *)
(*     intros * henc_len hdata_len hvalid_len hconfig hreg_fn hstructs. *)
(*     unfold fifo_addrs_not_in_range. *)
(*     assert (forall reg ext, interp_sval pkg ext (reg_fn reg) = st.[_id reg]) as hreg_fn'. *)
(*     { intros. split_cases; auto. } *)
(*     cbn. repeat rewrite hreg_fn'. *)
(*     consider addr_in_config. consider addr_in_region. *)
(*     pose proof (eta_expand_list_correct false st.[_id reg_enclave]) as Hdata. rewrite henc_len in Hdata. *)
(*     pose proof (eta_expand_list_correct false st.[_id reg_data]) as Hreg_data; rewrite hdata_len in Hreg_data. *)
(*     pose proof (eta_expand_list_correct false st.[_id reg_valid]) as Hreg_valid; rewrite hvalid_len in Hreg_valid. *)
(*     cbn in Hdata. cbn in Hreg_data. cbn in Hreg_valid. rewrite hstructs. *)
(*     consider region_in_config. *)
(*     split. *)
(*     - intros; propositional. apply H; clear H. *)
(*       destruct H1 as [heid0 | [heid1 | [heid2 | [ heid3 | hsid ] ] ] ]; propositional. *)
(*       + exists (MemRegion_Enclave Enclave0); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + exists (MemRegion_Enclave Enclave1); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + exists (MemRegion_Enclave Enclave2); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + exists (MemRegion_Enclave Enclave3); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + destruct hsid as [hsid01 | [hsid02 | [hsid03 | [ hsid12 | [ hsid13 | hsid23 ] ] ] ] ]; propositional. *)
(*         * exists (MemRegion_Shared Shared01); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared02); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared03); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared12); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared13); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*         * exists (MemRegion_Shared Shared23); split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*     - intros; propositional. apply H; clear H. destruct region. *)
(*       + destruct eid; [left | right; left | right; right; left| right; right; right; left]; *)
(*           config_req_addrs_in_range_simplify; *)
(*           split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + destruct id; do 4 right; *)
(*                      [left *)
(*                      | right; left *)
(*                      | right; right; left *)
(*                      | right; right; right; left *)
(*                      | right; right; right; right; left *)
(*                      | right; right; right; right; right]. *)
(*         all: split_ands_in_goal; repeat config_req_addrs_in_range_simplify. *)
(*       + discriminate. *)
(*   Qed. *)

(*   Lemma config_req_addrs_not_in_range_iff: *)
(*     forall core st config pkg reg_fn , *)
(*     WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) st -> *)
(*     WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) pkg.(pkg_init_st) -> *)
(*     enc_data_valid core st = Ob~0 \/ (enc_data_valid core st = Ob~1 -> unsafe_enclave_data_to_config st.[_id (SM.lookup_reg_enc_data core)] = config) -> *)
(*     (reg_fn = impl_init /\ st = pkg.(pkg_init_st)) \/ *)
(*     (reg_fn = impl_final /\ st = pkg.(pkg_final_st)) -> *)
(*     file_struct_defs (pkg_machine pkg) = SM.struct_defs -> *)
(*     req_addrs_not_in_range (other_core core) st config <-> *)
(*       interp_fancy_spred pkg (foo_other_req_addrs_not_in_range core reg_fn impl_get_field). *)
(*   Proof. *)
(*     intros * hwf_final hwf_init hconfig hcase hstructs. *)
(*     unfold foo_other_req_addrs_not_in_range. *)
(*     destruct core; simpl. *)
(*     - unfold interp_fancy_spred. unfold req_addrs_not_in_range. hnf. *)
(*       rewrite interp_fancy_spred'_PBase. *)
(*       rewrite interp_spred'_PImpl. *)
(*       repeat rewrite interp_spred'_PFancy. *)
(*       consider enc_data_valid. *)
(*       repeat rewrite interp_fancy_spred'_PBase. *)
(*       rewrite interp_spred'_PAnd. *)
(*       repeat rewrite interp_spred'_PFancy. *)
(*       destruct hcase as [hcase| hcase]; propositional. *)
(*       { destruct hconfig. *)
(*         { split; propositional; try congruence. *)
(*           + cbn in H1. rewrite hstructs in H1. setoid_rewrite H in H1. discriminate. *)
(*           + setoid_rewrite H in H1. congruence. *)
(*         } *)
(*         split; propositional. *)
(*         - cbn in H1. rewrite hstructs in H1. propositional. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*         - assert_pre_and_specialize H0. *)
(*           { cbn. rewrite hstructs. auto. } *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*                 try apply WF_state_length with (1 := hwf_init); auto. *)
(*       } *)
(*       { destruct hconfig. *)
(*         { split; propositional; try congruence. *)
(*           + cbn in H1. rewrite hstructs in H1. setoid_rewrite H in H1. discriminate. *)
(*           + setoid_rewrite H in H1. congruence. *)
(*         } *)
(*         split; propositional. *)
(*         - cbn in H1. rewrite hstructs in H1. propositional. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*         - assert_pre_and_specialize H0. *)
(*           { cbn. rewrite hstructs; auto. } *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*       } *)
(*     - unfold interp_fancy_spred. unfold req_addrs_not_in_range. hnf. *)
(*       rewrite interp_fancy_spred'_PBase. *)
(*       rewrite interp_spred'_PImpl. *)
(*       repeat rewrite interp_spred'_PFancy. *)
(*       consider enc_data_valid. *)
(*       repeat rewrite interp_fancy_spred'_PBase. *)
(*       rewrite interp_spred'_PAnd. *)
(*       repeat rewrite interp_spred'_PFancy. *)
(*       destruct hcase as [hcase| hcase]; propositional. *)
(*       { destruct hconfig. *)
(*         { split; propositional; try congruence. *)
(*           + cbn in H1. rewrite hstructs in H1. setoid_rewrite H in H1. discriminate. *)
(*           + setoid_rewrite H in H1. congruence. *)
(*         } *)
(*         split; propositional. *)
(*         - cbn in H1. rewrite hstructs in H1. propositional. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*         - assert_pre_and_specialize H0. *)
(*           { cbn. rewrite hstructs. auto. } *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*                 try apply WF_state_length with (1 := hwf_init); auto. *)
(*       } *)
(*       { destruct hconfig. *)
(*         { split; propositional; try congruence. *)
(*           + cbn in H1. rewrite hstructs in H1. setoid_rewrite H in H1. discriminate. *)
(*           + setoid_rewrite H in H1. congruence. *)
(*         } *)
(*         split; propositional. *)
(*         - cbn in H1. rewrite hstructs in H1. propositional. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*         - assert_pre_and_specialize H0. *)
(*           { cbn. rewrite hstructs; auto. } *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           rewrite config_fifo_addrs_not_in_range_iff in *; eauto. *)
(*           all:  try apply WF_state_length with (1 := hwf_final); *)
(*             try apply WF_state_length with (1 := hwf_init); auto. *)
(*       } *)

(*   Qed. *)
(* Hint Resolve @SimInvariant__ImplInvariant: modularity. *)
(* Hint Resolve @SimPreStepSM__Invariant: modularity. *)

(* Lemma SimPreStepSM'_implies: *)
(*   forall core impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost, *)
(*   WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) impl_st -> *)
(*   WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) spec_st -> *)
(*   unsafe_enclave_data_to_config impl_st.[_id (SM.lookup_reg_enc_data core)] = ghost-> *)
(*   SimPreStepSM core impl_st spec_st impl_sigma spec_sigma ghost -> *)
(*   SimPreStepSM' core impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost. *)
(* Proof. *)
(*   intros * hwf_impl hwf_spec hconfig hpre. *)
(*   constructor. *)
(*   - eapply SimPreStepSM__ghost; eauto. *)
(*   - constructor. { eapply SimPreStepSM__running; eauto. } *)
(*     constructor. { eapply SimPreStepSM__valid; eauto. } *)
(*     constructor. { specialize SimPreStepSM__sim_led with (1 := hpre). auto. } *)
(*     constructor. { specialize SimPreStepSM__sim_uart_read with (1 := hpre). auto. } *)
(*     constructor. { specialize SimPreStepSM__sim_uart_write with (1 := hpre). auto. } *)
(*     constructor. { specialize SimInvariant__sim with (1 := SimPreStepSM__Invariant _ _ _ _ _ _ hpre). auto. } *)
(*     constructor. { rewrite interp_fancy_spred2_using_impl_only by (destruct core; reflexivity). *)
(*                    rewrite<-config_req_addrs_in_range_iff with (st := impl_st); eauto. *)
(*                    eapply SimInvariant__valid_addrs__impl. eauto with modularity. *)
(*                  } *)
(*     constructor. { rewrite interp_fancy_spred2_using_impl_only by (destruct core; reflexivity). *)
(*                    rewrite<-config_req_addrs_not_in_range_iff with (st := impl_st); eauto. *)
(*                    eapply SimInvariant__valid_addrs__impl_other. *)
(*                    eauto with modularity. *)
(*                  } *)
(*     constructor. { rewrite interp_fancy_spred2_using_spec_only by (destruct core; reflexivity). *)
(*                    erewrite fancy_spred_equiv_correct. *)
(*                    rewrite<-config_req_addrs_in_range_iff with (st := spec_st) (core := core); eauto. *)
(*                    - erewrite<-SimInvariant__sim; eauto with modularity. *)
(*                      erewrite hconfig. *)
(*                      eapply SimInvariant__valid_addrs__spec; eauto with modularity. *)
(*                      destruct core; solve_In_to_find. *)
(*                    - replace (foo_req_addrs_in_range core impl_init impl_get_field) with *)
(*                           (normalize_mid_fancy_spred(foo_req_addrs_in_range core spec_init spec_get_field)) by (destruct core; reflexivity). *)
(*                    eapply normalize_spred_equiv. *)
(*                  } *)
(*     constructor. { eapply SimInvariant__other_mmio_empty. eauto with modularity. } *)
(*     constructor. { eapply ImplInvariant__mmio_req_in_range0. eauto with modularity. } *)
(*     constructor. { eapply ImplInvariant__mmio_req_in_range1. eauto with modularity. } *)
(*     constructor. { eapply ImplInvariant__disjoint_configs. eauto with modularity. } *)
(*     constructor. { eapply ImplInvariant__disjoint_eid. eauto with modularity. } *)
(*     constructor. { eapply ImplInvariant__disjoint_sid. eauto with modularity. } *)
(*     constructor. { eapply ImplInvariant__reset_correct0. eauto with modularity. } *)
(*     constructor. { eapply ImplInvariant__reset_correct1. eauto with modularity. } *)
(*     constructor. { eapply ImplInvariant__reset_mem_correct0 with (impl_st := impl_st). *)
(*                    eauto with modularity. *)
(*                  } *)
(*     constructor. { eapply ImplInvariant__reset_mem_correct1 with (impl_st := impl_st). *)
(*                    eauto with modularity. *)
(*                  } *)
(*     constructor. { eapply ImplInvariant__running_inv0 with (impl_st := impl_st). *)
(*                    eauto with modularity. *)
(*                  } *)
(*     constructor. { eapply ImplInvariant__running_inv1 with (impl_st := impl_st). *)
(*                    eauto with modularity. *)
(*                  } *)
(*     constructor. { eapply ImplInvariant__enc_req0 with (impl_st := impl_st). *)
(*                    eauto with modularity. *)
(*                  } *)
(*     constructor. { eapply ImplInvariant__enc_req1 with (impl_st := impl_st). *)
(*                    eauto with modularity. *)
(*                  } *)
(*     constructor. *)
(*   Qed. *)

(* Lemma SimPostStepSM'_implies0: *)
(*   forall impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost, *)
(*   WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) impl_st -> *)
(*   WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) spec_st -> *)
(*   WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) impl_st' -> *)
(*   WF_state (SortedRegEnv.to_list Machine.SM.reg_type_env) spec_st' -> *)
(*   unsafe_enclave_data_to_config impl_st.[_id (SM.lookup_reg_enc_data CoreId0)] = ghost-> *)
(*   unsafe_enclave_data_to_config spec_st.[_id (SM.lookup_reg_enc_data CoreId0)] = ghost-> *)
(*   (enc_data_valid CoreId0 impl_st = [true]) -> *)
(*   (*  impl_st'.[_id (SM.lookup_reg_enc_data CoreId0)] = impl_st.[_id (SM.lookup_reg_enc_data CoreId0)]) -> *) *)
(*   SimPostStepSM' CoreId0 impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost -> *)
(*   SimPostStepSM CoreId0 impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost. *)
(* Proof. *)
(*   intros * hwf_impl hwf_spec hwf_impl' hwf_spec' hghost hghost' hvalid. consider SimPostStepSM'. *)
(*   intros (himpl_taint & hspec_taint & himpl_push & hspec_push & H). *)
(*   assert (enc_data_valid CoreId0 impl_st' = [false] \/ *)
(*             (enc_data_valid CoreId0 impl_st' = [true] -> *)
(*              unsafe_enclave_data_to_config impl_st'.[_id (SM.lookup_reg_enc_data CoreId0)] = ghost)) as Hvalid. *)
(*   { specialize case_singleton_bv with (bs := enc_data_valid CoreId0 impl_st'); intros Hcase. *)
(*     prop_pose_with_custom HFoo Custom_SimPostStepSM__config_preserved H. *)
(*     cbn in HFoo. *)
(*     assert_pre_and_specialize Hcase. *)
(*     { consider enc_data_valid. unfold unsafe_get_field. unfold success_or_default. simpl. *)
(*       unsafe_simplify_structs_as foo. *)
(*       assert_pre_and_specialize foo; simplify; auto. *)
(*       eapply WF_state_length; eauto. *)
(*     } *)
(*     destruct Hcase as [Hcase | Hcase]; auto. right; propositional. *)
(*       setoid_rewrite HFoo. auto. *)
(*   } *)

(*   constructor. *)
(*   - constructor. *)
(*     + constructor; auto. *)
(*     + auto. *)
(*     + prop_apply_with_custom Custom_PostStepSM__config_same0 H. *)
(*   - constructor. *)
(*     + constructor; auto. *)
(*     + auto. *)
(*   - rewrite config_led_iff with (1 := hghost). *)
(*     prop_apply_with_custom Custom_SimPostStepSM__led H. *)
(*   - rewrite config_uart_iff with (1 := hghost). *)
(*     prop_apply_with_custom Custom_SimPostStepSM__uart_read H. *)
(*   - rewrite config_uart_iff with (1 := hghost). *)
(*     prop_apply_with_custom Custom_SimPostStepSM__uart_write H. *)
(*   - constructor. *)
(*     + prop_apply_with_custom Custom_SimInvariant__reg_sim H. *)
(*     + rewrite config_req_addrs_in_range_iff with (reg_fn := impl_final); eauto. *)
(*       { erewrite<-interp_fancy_spred2_using_impl_only. *)
(*         prop_pose_with_custom Foo Custom_SimInvariant__valid_addrs_impl H. *)
(*         eapply Foo. *)
(*         reflexivity. *)
(*       } *)
(*       all: auto. *)
(*       + rewrite config_req_addrs_not_in_range_iff with (reg_fn := impl_final); eauto. *)
(*       { prop_pose_with_custom Foo Custom_SimInvariant__valid_addrs_impl_other H. *)
(*         erewrite interp_fancy_spred2_using_impl_only in Foo by reflexivity. *)
(*         rewrite fancy_spred_equiv_correct in Foo. *)
(*         2: { eapply normalize_spred_equiv. } *)
(*         eapply Foo. *)
(*       } *)
(*       all: eauto. *)
(*     + rewrite config_req_addrs_in_range_iff with (reg_fn := impl_final); eauto. *)
(*       { prop_pose_with_custom Foo Custom_SimInvariant__valid_addrs_spec H. *)
(*         erewrite interp_fancy_spred2_using_spec_only in Foo by reflexivity. *)
(*         rewrite fancy_spred_equiv_correct in Foo. *)
(*         2: { eapply normalize_spred_equiv. } *)
(*         eapply Foo. *)
(*       } *)
(*       all: eauto. *)
(*       unfold enc_data_valid. *)

(*       (* TODO: remove *) *)
(*       Ltac prop_rev_rewrite_with_custom name h := *)
(*         let foo := constr:(prop_custom_lookup_name' _ _ _ name _ h eq_refl) in *)
(*         setoid_rewrite<-foo. *)
(*       prop_rev_rewrite_with_custom Custom_SimInvariant__reg_sim H; auto. *)
(*       all: solve_In_to_find. *)
(*    + prop_apply_with_custom Custom_SimInvariant__other_mmio_empty H. *)
(*    + constructor. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__mmio_req_in_range0 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__mmio_req_in_range1 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__disjoint_eid H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__disjoint_sid H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__disjoint_configs H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__reset0 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__reset1 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__reset_mem0 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__reset_mem1 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__running_inv0 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__running_inv1 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__enc_req0 H. *)
(*      * prop_apply_with_custom Custom_ImplInvariant__enc_req1 H. *)
(* Qed. *)

(*   Lemma interp_sm_sim0: *)
(*    sim_interp_scheduler_satisfies_spec *)
(*      Machine.SM.reg_type_env _ext_fn_tys *)
(*      SM._int_fns SM._int_fns *)
(*      SM._struct_defs SM._struct_defs *)
(*      (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl)) *)
(*      (fun rl : sm_rule_name_t => id_transform_action snd (SM.rules rl)) *)
(*      SM.schedule Implementation.Core0Machine.sm0_schedule enclave_config *)
(*      (fun impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost => *)
(*         SimPreStepSM CoreId0 impl_st spec_st impl_sigma spec_sigma ghost) *)
(*      (SimPostStepSM CoreId0). *)
(*   Proof. *)
(*     specialize TEST_interp_sm_sim0. *)
(*     unfold sim_interp_scheduler_satisfies_spec. *)
(*     intros htest. *)
(*     intros * hwf_impl hwf_spec hwf_impl_sigma hwf_spec_sigma hwf_impl_fns hwf_spec_fns *)
(*              himpl_step hspec_step hpre. *)
(*     specialize typecheck_scheduler_correct'' with (5 := himpl_step) (2 := hwf_impl) (3 := hwf_impl_sigma) (4 := hwf_impl_fns) (1 := eq_refl). intros (hwf_impl' & wf_impl_ext'). *)
(*     specialize typecheck_scheduler_correct'' with (5 := hspec_step) (2 := hwf_spec) (3 := hwf_spec_sigma) (4 := hwf_spec_fns) (1 := eq_refl). intros (hwf_spec' & wf_spec_ext'). *)
(*     split_ands_in_goal; auto. *)
(*     specialize htest with (7 := himpl_step) (8 := hspec_step) (ghost := ghost). propositional. *)
(*     assert_pre_as hpre' htest. *)
(*     { eapply SimPreStepSM'_implies; auto. *)
(*       - apply strong_WF_state_weaken. auto. *)
(*       - apply strong_WF_state_weaken. auto. *)
(*       -  eapply SimPreStepSM__ghost; eauto. *)
(*     } *)
(*     propositional. *)
(*     propositional. *)
(*     apply SimPostStepSM'_implies0; auto. *)
(*     - apply strong_WF_state_weaken. auto. *)
(*     - apply strong_WF_state_weaken. auto. *)
(*     - apply strong_WF_state_weaken. auto. *)
(*     - apply strong_WF_state_weaken. auto. *)
(*     - eapply SimPreStepSM__ghost; eauto. *)
(*     - erewrite<-SimInvariant__sim with (impl_st := impl_st). *)
(*       + eapply SimPreStepSM__ghost; eauto. *)
(*       + eapply SimPreStepSM__Invariant; eauto. *)
(*       + solve_In_to_find. *)
(*     - eapply SimPreStepSM__valid; eauto. *)
(*   Qed. *)
(*   Lemma sm_sim_implies_config_regs_eq: *)
(*     forall core impl_st' spec_st' config , *)
(*     (* SimPost core impl_st impl_st' spec_st spec_st' config impl_out spec_out  cycles -> *) *)
(*     SimInvariant core (machine_koika_st impl_st') (machine_koika_st spec_st')(config)  -> *)
(*     (machine_koika_st impl_st').[_id (SM.lookup_reg_state core)] = (machine_koika_st spec_st').[_id (SM.lookup_reg_state core)] /\ *)
(*     (machine_koika_st impl_st').[_id (SM.lookup_reg_enc_data core)] = (machine_koika_st spec_st').[_id (SM.lookup_reg_enc_data core)] /\ *)
(*     (machine_koika_st impl_st').[_id (SM.lookup_reg_enc_req core)] = (machine_koika_st spec_st').[_id (SM.lookup_reg_enc_req core)]. *)
(*   Proof. *)
(*     intros * hinv. destruct hinv. *)
(*     repeat rewrite SimInvariant__sim0; auto. *)
(*     all: destruct core; solve_In_to_find. *)
(*   Qed. *)

(* End SM_Proof. *)
(* Require Import koikaExamples.Enclaves.External. *)
(* (* TODO: figure out module system *) *)
(* Module SM_ConcreteProof . *)
(*   Module SecurityParams := Empty <+ SecurityParams_sig EnclaveParams. *)
(*   Module SM_Params := Empty <+ SM_Proof EnclaveParams SecurityParams. *)
(*   Import SM_Params. *)

(*   (* Definition test_sched := *) *)
(*   (*   map (fun rl : sm_rule_name_t => (rl, show rl)) *) *)
(*   (*     [ Rl_FilterReqs0; Rl_FilterReqs1 *) *)
(*   (*       ; Rl_DoMMIO *) *)
(*   (*       ; Rl_ForwardResps0; Rl_ForwardResps1 *) *)
(*   (*       ; Rl_UpdateEnclave0; Rl_UpdateEnclave1 *) *)
(*   (*       ; Rl_EnterEnclave0; Rl_EnterEnclave1 *) *)
(*   (*       ; Rl_ExitEnclave0; Rl_ExitEnclave1 *) *)
(*   (*       ; Rl_DoClk]. *) *)

(*   (* Definition test_sched0 := *) *)
(*   (*   map (fun rl : sm_rule_name_t => (rl, show rl)) *) *)
(*   (*     [ *) *)
(*   (*         Rl_FilterReqs0 *) *)
(*   (*       ; Rl_DoMMIO (* TODO: move elsewhere? *) *) *)
(*   (*       ; Rl_ForwardResps0 *) *)
(*   (*       ; Rl_UpdateEnclave0 *) *)
(*   (*       ; Rl_EnterEnclave0 *) *)
(*   (*       ; Rl_ExitEnclave0 *) *)
(*   (*       ; Rl_DoClk]. *) *)
(*   (*   Definition test_impl_machine : machine_t := *) *)
(*   (*     {| file_registers := SM.reg_list; *) *)
(*   (*        file_ext_sigma := ext_fn_tys; *) *)
(*   (*        file_struct_defs := SM.struct_defs; *) *)
(*   (*        file_schedule := preprocess_schedule impl_typecheck_fn SM.rules  test_sched *) *)
(*   (*     |}. *) *)
(*   (*   Definition test_spec0_machine : machine_t := *) *)
(*   (*     {| file_registers := SM.reg_list; *) *)
(*   (*        file_ext_sigma := ext_fn_tys; *) *)
(*   (*        file_struct_defs := SM.struct_defs; *) *)
(*   (*        file_schedule := preprocess_schedule impl_typecheck_fn SM.rules  test_sched0 *) *)
(*   (*     |}. *) *)
(*   (*   Definition file: file_t := *) *)
(*   (*     Eval vm_compute in *) *)
(*   (*     {| file_machines := Product test_impl_machine test_spec0_machine; *) *)
(*   (*        file_assumptions := List.concat (map (fun '(_, p) => (flatten_spred_ands (unfancy p))) (foo_SimPreStepSM CoreId0)); *) *)
(*   (*        file_assertions := List.concat ((map (fun '(_, p) => (flatten_spred_ands (unfancy p)))) (foo_SimPostStepSM CoreId0)) *) *)
(*   (*     |}. *) *)
(*   (*   Extraction "../../../Test.ml" struct_sz vect_t file. *) *)
(* (* Eval hnf in (lookup_reg_id 1). *) *)
(* (* Print SM.reg_list. *) *)
(* (* Eval cbv in (SM.fromMMIO0.REG_data0). *) *)
(* (* Print SM.sm_do_mmio. *) *)
(* (* Print SM.FN_mmio_bus. *) *)
(* (* (* Need invariant: MMIO requests must be in range *) *) *)
(*   Definition file: file_t := *)
(*     Eval vm_compute in *)
(*     {| file_machines := Product impl_machine spec0_machine impl_schedule spec0_schedule; *)
(*        file_assumptions := preprocess_fancy_spreds (foo_SimPreStepSM CoreId0); *)
(*        file_assertions := preprocess_fancy_spreds (foo_SimPostStepSM CoreId0); *)
(*     |}. *)

(*   Extraction "../../../Test.ml" struct_sz vect_t file. *)


(*   Lemma WF_product_file_sim0: WF_product_file file = true. *)
(*   Proof. *)
(*   Admitted. *)

(*   (* TODO: fix parameter *) *)
(*   Theorem smt_sim0_correct: *)
(*     symbolic_evaluate_file_success_product *)
(*       impl_machine spec0_machine impl_schedule spec0_schedule *)
(*       (preprocess_fancy_spreds (foo_SimPreStepSM CoreId0)) *)
(*       (preprocess_fancy_spreds (foo_SimPostStepSM CoreId0)). *)
(*   Proof. *)
(*     intros. *)
(*     specialize symbolic_evaluate_file_success with (file := file). *)
(*     assert (file_machines file = Product impl_machine spec0_machine impl_schedule spec0_schedule) by (vm_compute; reflexivity). *)
(*     assert (file_assumptions file = *)
(*               List.concat (map (fun '(_, p) => (flatten_spred_ands (unfancy p))) (foo_SimPreStepSM CoreId0))) *)
(*              by (vm_compute; reflexivity). *)
(*      assert (file_assertions file = *)
(*               List.concat (map (fun '(_, p) => (flatten_spred_ands (unfancy p))) (foo_SimPostStepSM CoreId0))) *)
(*              by (vm_compute; reflexivity). *)
(*     rewrite H. intros. *)
(*     apply H2. apply WF_product_file_sim0. *)
(*   Qed. *)

(*   Extraction "../../../ExtractionSMSim0.ml" struct_sz vect_t file. *)

(* End SM_ConcreteProof. *)
