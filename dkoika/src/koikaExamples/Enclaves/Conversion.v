(* Require Import koika.Frontend. *)

(* Require Koika.Frontend. *)
(* Require Import Koika.Interop. *)
(* Require Koika.Syntax. *)
(* Require Import koika.Frontend. *)


(* Record koika_pkg_t {T: Type} {rule_name_t: Type} := *)
(* { pkg_reg_types: @reg_types_t T *)
(* ; pkg_reg_inits: list (T * list bool) *)
(* ; pkg_ext_fn_tys: @ext_fn_types_t T *)
(* ; pkg_int_fns: @int_fn_env_t T (@action T) *)
(* ; pkg_struct_defs: @struct_env_t T *)
(* ; pkg_rules: rule_name_t -> @Syntax.rule T *)
(* ; pkg_scheduler: @scheduler rule_name_t *)
(* ; pkg_rl_external: rule_name_t -> bool *)
(* ; pkg_module_name: string *)
(* }. *)

(* Arguments koika_pkg_t : clear implicits. *)

(* Instance Show_N : Koika.Show.Show N := *)
(*   { show := fun n => (Show_nat.string_of_nat (N.to_nat n))%string }. *)

(* Section Convert. *)
(*   Context {id_ty rule_name_t reg_t ext_fn_t: Type}. *)
(*   Context {EqDec_id_ty: EqDec id_ty}. *)
(*   Context {FT_reg_t: FiniteType reg_t}. *)
(*   Context {Show_id_ty: Koika.Show.Show id_ty}. *)
(*   Context {Show_reg_t: Koika.Show.Show reg_t}. *)
(*   Context {Show_rule_name_t: Koika.Show.Show rule_name_t}. *)
(*   Context (reg_to_id: reg_t -> id_ty). *)
(*   Context (id_to_reg: id_ty -> result reg_t unit). *)
(*   Context (ext_fn_t_to_id: ext_fn_t -> id_ty). *)
(*   Context (id_to_ext_fn_t: id_ty -> result ext_fn_t unit). *)


(*   Definition convert_reg_types (tys: @reg_types_t id_ty) : reg_t -> type := *)
(*     fun reg => match find (fun '(r, _) => beq_dec (reg_to_id reg) r) tys with *)
(*             | Some (_, ty) => bits_t ty *)
(*             | None => bits_t 0 (* TODO *) *)
(*             end. *)

(*   Definition convert_reg_inits (reg_inits: list (id_ty * list bool)) *)
(*                                (tys: @reg_types_t id_ty) *)
(*                                : (forall r: reg_t, convert_reg_types tys r). *)
(*   Proof. *)
(*   (* TODO *) *)
(*     intros. unfold convert_reg_types. destruct_match; destruct_match_pairs; subst. *)
(*     - destruct_with_eqn (find (fun '(r', _) => beq_dec r' (reg_to_id r)) reg_inits). *)
(*       + destruct p. *)
(*         exact (Koika.Vect.Bits.slice 0 n (vect_of_list l)). *)
(*       + exact (Koika.Vect.Bits.zeroes n). *)
(*     - exact vect_nil. *)
(*   Defined. *)

(*   Definition convert_ext_fn_tys (ext_tys: @ext_fn_types_t id_ty) *)
(*                                 : ext_fn_t -> ExternalSignature := *)
(*   fun ext_fn => *)
(*     match find (fun '(name, _) => (beq_dec name (ext_fn_t_to_id ext_fn))) ext_tys with *)
(*     | Some (_, (arg_t,ret_t)) => *)
(*         {| argSigs := vect_cons (bits_t arg_t) vect_nil; *)
(*            retSig := bits_t ret_t *)
(*         |} *)
(*     | _ => *)
(*         {| argSigs := vect_cons (bits_t 0) vect_nil; *)
(*            retSig := bits_t 0 *)
(*         |} *)
(*     end. *)

(*   Notation uaction := (@Koika.Syntax.uaction Frontend.pos_t var_t string reg_t ext_fn_t). *)

(*   Section ConvertRule. *)
(*     Context (struct_env: @struct_env_t id_ty). *)
(*     Context (int_fn_env: @int_fn_env_t id_ty (@action id_ty)). *)

(*     Import Koika.Syntax. *)
(*     Import koika.Frontend. *)

(*     Definition pos_t := Frontend.pos_t. *)
(*     Definition fn_name_t := string. *)

(*     Notation uaction := (@Koika.Syntax.uaction pos_t var_t fn_name_t reg_t ext_fn_t). *)
(*     Definition convert_port (p: Port) : Koika.Types.Port := *)
(*       match p with *)
(*       | P0 => Koika.Types.P0 *)
(*       | P1 => Koika.Types.P1 *)
(*       end. *)

(*     Definition lookup_struct (sname: id_ty) : result struct_t unit := *)
(*       match find (fun s => beq_dec sname s.(dstruct_name)) struct_env with *)
(*       | Some s => Success s *)
(*       | None => Failure tt *)
(*       end. *)
(*     Definition struct_to_struct0 (s: @struct_t id_ty) : struct_sig := *)
(*       {| Koika.Types.struct_name := @Koika.Show.show _ Show_id_ty s.(dstruct_name); *)
(*          Koika.Types.struct_fields := map (fun '(fld, sz) => (@Koika.Show.show _ Show_id_ty fld, bits_t sz)) s.(dstruct_fields) *)
(*       |}. *)

(*     Definition sname_to_struct0 (sname: id_ty) : result struct_sig unit := *)
(*       let/res s := lookup_struct sname in *)
(*       Success (struct_to_struct0 s). *)

(*     Definition convert_bits1 (fn: bits1) : PrimUntyped.ubits1 := *)
(*       match fn with *)
(*       | Not =>  PrimUntyped.UNot *)
(*       | Slice offset width => PrimUntyped.USlice offset width *)
(*       | SExt width => PrimUntyped.USExt width *)
(*       | ZExtL width => PrimUntyped.UZExtL width *)
(*       end. *)

(*     (* TODO: bits or struct? *) *)
(*     Definition convert_struct1 (fn: struct1) : result PrimUntyped.ustruct1 unit := *)
(*       match fn with *)
(*       | GetField sname sfield => *)
(*           let/res sig := sname_to_struct0 sname in *)
(*           Success (PrimUntyped.UGetFieldBits sig (@Koika.Show.show _ Show_id_ty sfield)) *)
(*       end. *)

(*     Definition convert_fn1 (fn: @fn1 id_ty) : result PrimUntyped.ufn1 unit := *)
(*       match fn with *)
(*       | Bits1 fn => Success (PrimUntyped.UBits1 (convert_bits1 fn)) *)
(*       | Struct1 fn => *)
(*           let/res sfn := convert_struct1 fn in *)
(*           Success (PrimUntyped.UStruct1 sfn) *)
(*       | Ignore => Success (PrimUntyped.UConv PrimUntyped.UIgnore) *)
(*       end. *)

(*     Definition convert_bits_comparison (cmp: bits_comparison) : Koika.Primitives.bits_comparison := *)
(*       match cmp with *)
(*       | cLt => Koika.Primitives.cLt *)
(*       | cGt => Koika.Primitives.cGt *)
(*       | cLe => Koika.Primitives.cLe *)
(*       | cGe => Koika.Primitives.cGe *)
(*       end. *)

(*     Definition convert_struct2 (fn: @struct2 id_ty) : result PrimUntyped.ustruct2 unit := *)
(*       match fn with *)
(*       | SubstField sname sfield => *)
(*           let/res sig := sname_to_struct0 sname in *)
(*           Success (PrimUntyped.USubstFieldBits sig (Koika.Show.show sfield)) *)
(*       end. *)

(*     Definition convert_fn2 (fn: @fn2 id_ty) : result PrimUntyped.ufn2 unit := *)
(*       match fn with *)
(*       | Bits2 fn => *)
(*         match fn with *)
(*         | And => Success (PrimUntyped.UBits2 (PrimUntyped.UAnd)) *)
(*         | Or  => Success (PrimUntyped.UBits2 (PrimUntyped.UOr)) *)
(*         | Xor => Success (PrimUntyped.UBits2 (PrimUntyped.UXor)) *)
(*         | Lsl  => Success (PrimUntyped.UBits2 (PrimUntyped.ULsl)) *)
(*         | Lsr  => Success (PrimUntyped.UBits2 (PrimUntyped.ULsr)) *)
(*         | Asr  => Success (PrimUntyped.UBits2 (PrimUntyped.UAsr)) *)
(*         | Concat  => Success (PrimUntyped.UBits2 (PrimUntyped.UConcat)) *)
(*         | Sel  => Success (PrimUntyped.UBits2 (PrimUntyped.USel)) *)
(*         | Plus => Success (PrimUntyped.UBits2 (PrimUntyped.UPlus)) *)
(*         | Minus  => Success (PrimUntyped.UBits2 (PrimUntyped.UMinus)) *)
(*         | EqBits negate => Success (PrimUntyped.UEq negate) *)
(*         | Compare signed c => Success (PrimUntyped.UBits2 (PrimUntyped.UCompare signed (convert_bits_comparison c))) *)
(*         | IndexedSlice width => Success (PrimUntyped.UBits2 (PrimUntyped.UIndexedSlice width )) *)
(*         end *)
(*       | Struct2 fn => *)
(*           let/res sfn := convert_struct2 fn in *)
(*           Success (PrimUntyped.UStruct2 sfn) *)
(*       end. *)

(*     Definition lookup_fn (fname: id_ty) : result int_fn_spec_t unit := *)
(*        match find (fun s => beq_dec fname s.(fn_name)) int_fn_env with *)
(*       | Some s => Success s *)
(*       | None => Failure tt *)
(*       end. *)
(*     Context (Sigma: ext_fn_t -> ExternalSignature). *)
(*     Fixpoint convert_rule (fuel: nat) (rule: @Syntax.rule id_ty) : result uaction unit := *)
(*       match fuel with *)
(*       | 0 => Failure tt *)
(*       | S fuel => *)
(*           let convert_rule := convert_rule fuel in *)
(*           match rule with *)
(*               | Fail sz => Success (UFail (bits_t sz)) *)
(*               | Var v => Success (UVar v) *)
(*               | Const cst => Success (USugar (UConstBits (vect_of_list cst))) *)
(*               | Assign v a => *)
(*                   let/res a := convert_rule a in *)
(*                   Success (UAssign v a) *)
(*               | Seq a1 a2 => *)
(*                   let/res a1 := convert_rule a1 in *)
(*                   let/res a2 := convert_rule a2 in *)
(*                   Success (USeq a1 a2) *)
(*               | If cond tbranch fbranch => *)
(*                   let/res cond := convert_rule cond in *)
(*                   let/res tbranch := convert_rule tbranch in *)
(*                   let/res fbranch := convert_rule fbranch in *)
(*                   Success (UIf cond tbranch fbranch) *)
(*               | Bind v ex body => *)
(*                   let/res ex := convert_rule ex in *)
(*                   let/res body := convert_rule body in *)
(*                   Success (UBind v ex body) *)
(*               | Read p idx => *)
(*                   let/res idx := id_to_reg idx in *)
(*                   Success (URead (convert_port p) idx) *)
(*               | Write p idx a => *)
(*                  let/res idx := id_to_reg idx in *)
(*                  let/res a := convert_rule a in *)
(*                  Success (UWrite (convert_port p) idx a) *)
(*               | Zop (StructInit sname) => *)
(*                  let/res sig := sname_to_struct0 sname in *)
(*                  Success (USugar (UConstBits (Koika.Vect.Bits.zeroes (type_sz (Koika.Types.struct_t sig))) )) *)
(*               | Unop fn a => *)
(*                 let/res a := convert_rule a in *)
(*                 let/res fn := convert_fn1 fn in *)
(*                 Success (UUnop fn a) *)
(*               | Binop fn a1 a2 => *)
(*                   let/res a1 := convert_rule a1 in *)
(*                   let/res a2 := convert_rule a2 in *)
(*                   let/res fn := convert_fn2 fn in *)
(*                   Success (UBinop fn a1 a2) *)
(*               | InternalCall fn a => *)
(*                   let/res a := convert_rule a in *)
(*                   let/res fn_spec := lookup_fn fn in *)
(*                   let/res body := convert_rule fn_spec.(fn_body) in *)
(*                   let fn0 := {| int_name := @Koika.Show.show _ Show_id_ty fn; *)
(*                                 int_argspec := [(fn_spec.(fn_arg_name), bits_t fn_spec.(fn_arg_ty))]; *)
(*                                 int_retSig := bits_t fn_spec.(fn_ret_ty); *)
(*                                 int_body := body *)
(*                              |} in *)
(*                   Success (UInternalCall fn0 [a]) *)
(*               | ExternalCall fn a => *)
(*                   let/res a := convert_rule a in *)
(*                   let/res fn := id_to_ext_fn_t fn in *)
(*                   let unpacked_arg := *)
(*                     (UUnop (PrimUntyped.UConv (PrimUntyped.UUnpack (Sigma fn).(arg1Sig))) a) in *)
(*                   let ret := UExternalCall fn unpacked_arg in *)
(*                   let packed_ret := UUnop (PrimUntyped.UConv PrimUntyped.UPack) ret in *)
(*                   Success packed_ret *)
(*               end *)
(*       end. *)

(*   End ConvertRule. *)
(*   Definition convert_rules *)
(*     (Sigma: ext_fn_t -> ExternalSignature) *)
(*     (reg_types: @reg_types_t id_ty) *)
(*     (ext_fn_tys: @ext_fn_types_t id_ty) *)
(*     (struct_defs: @struct_env_t id_ty) *)
(*     (int_fns: @int_fn_env_t id_ty (@action id_ty)) *)
(*     (rls: rule_name_t -> @Syntax.rule id_ty) *)
(*     : rule_name_t -> uaction := *)
(*     fun rl => *)
(*       match convert_rule struct_defs int_fns Sigma (safe_fuel int_fns (rls rl)) (rls rl) with *)
(*       | Success url => url *)
(*       | _ => *)
(*           (Syntax.UError {| epos := tt; *)
(*                             emsg := ExplicitErrorInAst; *)
(*                             esource := ErrSrc (SyntaxFunctions.ErrorHere 0) |}) *)
(*       end. *)

(*   Fixpoint convert_scheduler (sched: @scheduler rule_name_t) *)
(*                                : Koika.Syntax.scheduler pos_t rule_name_t := *)
(*     match sched with *)
(*     | done => Koika.Syntax.Done *)
(*     | Cons rl sched => Koika.Syntax.Cons rl (convert_scheduler sched) *)
(*     end. *)

(*   Definition convert_to_uactions *)
(*     (Sigma: ext_fn_t -> ExternalSignature) *)
(*     (pkg: koika_pkg_t id_ty rule_name_t) *)
(*     : rule_name_t -> uaction := *)
(*     fun rl => *)
(*       convert_rules Sigma pkg.(pkg_reg_types) pkg.(pkg_ext_fn_tys) *)
(*                     pkg.(pkg_struct_defs) pkg.(pkg_int_fns) *)
(*                     pkg.(pkg_rules) rl. *)


(*   (* Definition convert (pkg: koika_pkg_t id_ty rule_name_t) *) *)
(*   (*                    : @koika_package_t pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t := *) *)
(*   (*   let reg_types := convert_reg_types pkg.(pkg_reg_types) in *) *)
(*   (*   let reg_inits := convert_reg_inits pkg.(pkg_reg_inits) pkg.(pkg_reg_types) in *) *)
(*   (*   let rules := convert_rules pkg.(pkg_reg_types) pkg.(pkg_ext_fn_tys) *) *)
(*   (*                              pkg.(pkg_struct_defs) pkg.(pkg_int_fns) pkg.(pkg_rules) in *) *)
(*   (*   {| koika_reg_types := reg_types; *) *)
(*   (*      koika_reg_init := reg_inits; *) *)
(*   (*      koika_ext_fn_types := convert_ext_fn_tys pkg.(pkg_ext_fn_tys); *) *)
(*   (*      koika_rules := rules; *) *)
(*   (*      koika_rule_external := pkg.(pkg_rl_external); *) *)
(*   (*      koika_scheduler := convert_scheduler pkg.(pkg_scheduler); *) *)
(*   (*      koika_module_name := pkg.(pkg_module_name); *) *)
(*   (*   |}. *) *)

(* End Convert. *)
