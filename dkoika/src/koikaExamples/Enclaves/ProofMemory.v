(* Require Import rv_isolation.Common. *)
(* Require Import rv_isolation.SecurityMonitor. *)
(* Require Import rv_isolation.Memory. *)
(* Require Import koika.Frontend. *)
(* Require Import koikaExamples.Enclaves.Common. *)
(* Require Import koikaExamples.Enclaves.TypeDefs. *)
(* Require Import koikaExamples.Enclaves.Impl. *)
(* Require Import koikaExamples.Enclaves.Spec. *)
(* Require Import koikaExamples.Enclaves.Theorem. *)
(* Require Import koikaExamples.Enclaves.Utils. *)
(* Require Import FunctionalExtensionality. *)
(* Require Import koika.Symbolic. *)
(* Require Import koikaExamples.Enclaves.External. *)
(* Require Import koikaExamples.Enclaves.ExtractionUtils. *)
(* Require Import koika.AnnotatedSyntax. *)
(* Import ListNotations. *)

(* Module Type MemoryProofs (EnclaveParams: EnclaveParams_sig) *)
(*                          (SecurityParams: SecurityParams_sig EnclaveParams). *)
(*   Import Memory. *)
(*   Module Import Implementation := SecurityParams.Implementation. *)
(*   Import PfHelpers. *)
(*   Import SecurityParams.Impl. *)

(*   Section ImplMachine. *)
(*     Notation reg_t := (@reg_t debug_id_ty). *)
(*     Definition impl_schedule_list : list (Machine.rule_name_t * string) := *)
(*       map (fun rl => (rl, show rl)) (list_of_schedule (Impl.mem_schedule)). *)
(*     Definition impl_typecheck_fn rl : result (aaction * nat) unit := *)
(*       typecheck_rule reg_types ext_fn_tys int_fns struct_defs (inline_rule int_fns rl). *)
(*     Definition impl_schedule := *)
(*       preprocess_schedule impl_typecheck_fn rules impl_schedule_list. *)

(*     (* Goal preprocess_schedule_success impl_typecheck_fn SM.rules impl_schedule_list = true. *) *)
(*     (* Proof. vm_compute; reflexivity. Qed. *) *)
(*     Definition impl_machine : machine_t := *)
(*       {| file_registers := reg_types; *)
(*          file_ext_sigma := ext_fn_tys; *)
(*          file_struct_defs := struct_defs; *)
(*       |}. *)
(*   End ImplMachine. *)

(*   Section SpecMachine0. *)

(*     Definition spec0_schedule_list : list (Machine.rule_name_t * string) := *)
(*       map (fun rl => (Machine.RlMem rl, show (Machine.RlMem rl))) (list_of_schedule (mem_schedule CoreId0)). *)
(*     Definition spec0_typecheck_fn rl : result (aaction * nat) unit := *)
(*       typecheck_rule reg_types ext_fn_tys int_fns struct_defs (inline_rule int_fns rl). *)
(*     Definition spec0_schedule := *)
(*       preprocess_schedule spec0_typecheck_fn rules spec0_schedule_list. *)

(*     (* Goal preprocess_schedule_success impl_typecheck_fn Memory.rules spec0_schedule_list = true. *) *)
(*     (* Proof. vm_compute; reflexivity. Qed. *) *)

(*     Definition spec0_machine : machine_t := *)
(*       {| file_registers := reg_types; *)
(*          file_ext_sigma := ext_fn_tys; *)
(*          file_struct_defs := struct_defs; *)
(*       |}. *)
(*   End SpecMachine0. *)


(*   Section SpecMachine1. *)

(*     Definition spec1_schedule_list : list (Machine.rule_name_t * string) := *)
(*       map (fun rl => (Machine.RlMem rl, show (Machine.RlMem rl))) (list_of_schedule (mem_schedule CoreId1)). *)
(*     Definition spec1_typecheck_fn rl : result (aaction * nat) unit := *)
(*       typecheck_rule reg_types ext_fn_tys int_fns struct_defs (inline_rule int_fns rl). *)
(*     Definition spec1_schedule := *)
(*       preprocess_schedule spec1_typecheck_fn rules spec1_schedule_list. *)

(*     (* Goal preprocess_schedule_success impl_typecheck_fn Memory.rules spec1_schedule_list = true. *) *)
(*     (* Proof. vm_compute; reflexivity. Qed. *) *)

(*     Definition spec1_machine : machine_t := *)
(*       {| file_registers := reg_types; *)
(*          file_ext_sigma := ext_fn_tys; *)
(*          file_struct_defs := struct_defs; *)
(*       |}. *)
(*   End SpecMachine1. *)

(*   Definition _mrid reg := _rid (Memory reg). *)
(*   Definition _mid reg := reg_to_debug_id (Memory reg). *)

(*   Notation reg_t := debug_id_ty. *)

(*   Definition req_addrs_in_range (core: ind_core_id) (st: Environments.state_t) (config: enclave_config) : Prop := *)
(*     let (to_imem_data, to_imem_valid) := ((Memory.toIMem core) MemReq.data0, (Memory.toIMem core) MemReq.valid0) in *)
(*     let (to_dmem_data, to_dmem_valid) := ((Memory.toDMem core) MemReq.data0, (Memory.toDMem core) MemReq.valid0) in *)
(*     fifo_addrs_in_range EnclaveParams.enclave_sig st config (_mrid to_imem_valid) (_mrid to_imem_data) /\ *)
(*     fifo_addrs_in_range EnclaveParams.enclave_sig st config (_mrid to_dmem_valid) (_mrid to_dmem_data). *)

(*   Definition req_addrs_not_in_range (core: ind_core_id) (st: Environments.state_t) (config: enclave_config) : Prop := *)
(*     let (to_imem_data, to_imem_valid) := ((Memory.toIMem core) MemReq.data0, (Memory.toIMem core) MemReq.valid0) in *)
(*     let (to_dmem_data, to_dmem_valid) := ((Memory.toDMem core) MemReq.data0, (Memory.toDMem core) MemReq.valid0) in *)
(*     fifo_addrs_not_in_range EnclaveParams.enclave_sig st config (_mrid to_imem_valid) (_mrid to_imem_data) /\ *)
(*     fifo_addrs_not_in_range EnclaveParams.enclave_sig st config (_mrid to_dmem_valid) (_mrid to_dmem_data). *)
(*   Definition foo_reset_correct (core: ind_core_id) *)
(*                                (reg_fn: reg_t -> sval) *)
(*                                (get_field: debug_id_ty -> debug_id_ty -> sval -> sval) *)
(*                                    : fancy_spred := *)
(*     let mem_purge := purge core in *)
(*     let '(to_imem_valid, to_dmem_valid) := *)
(*       ((Memory.toIMem core) MemReq.valid0, (Memory.toDMem core) MemReq.valid0) in *)
(*     {{{`reg_fn (_mid mem_purge)` = #(_enum purge_state "Purged")  -> *)
(*         `reg_fn (_mid to_imem_valid)` = Ob~0 /\ *)
(*         `reg_fn (_mid to_dmem_valid)` = Ob~0 *)
(*     }}}. *)

(*   Definition impl_interp_spred_with_init_st_only (st: state_t) := *)
(*     interp_fancy_spred *)
(*       {| pkg_machine := impl_machine; *)
(*          pkg_init_st := st; *)
(*          pkg_sigma := fun _ _ => Failure tt; (* don't care *) *)
(*          pkg_mid_st := None; *)
(*          pkg_final_st := st; (* don't care *) *)
(*          pkg_mid_ext_log := None; *)
(*          pkg_ext_log' := SortedExtFnEnv.empty (* don't care *) *)
(*       |}. *)

(*   Record ImplInvariant (core: ind_core_id) (impl_st: koika_state_t) : Prop := *)
(*     { ImplInvariant__purged0: impl_interp_spred_with_init_st_only impl_st (foo_reset_correct CoreId0 impl_init impl_get_field); *)
(*       ImplInvariant__purged1: impl_interp_spred_with_init_st_only impl_st (foo_reset_correct CoreId1 impl_init impl_get_field) *)
(*     }. *)

(*   Record SimInvariant (core: ind_core_id) (impl_st: koika_state_t) (spec_st: koika_state_t) (config: enclave_config): Prop := *)
(*     { SimInvariant__sim: forall reg, (In reg (([_mid turn] ++ (map reg_to_debug_id (private_mem_regs core))) ++ (map reg_to_debug_id (ext_mem_regs core) )) ) -> *)
(*                               impl_st.[_id reg] = spec_st.[_id reg] *)
(*     ; SimInvariant__valid_addrs__impl: req_addrs_in_range core impl_st config *)
(*     ; SimInvariant__valid_addrs__impl_other: req_addrs_not_in_range (other_core core) impl_st config *)
(*     ; SimInvariant__valid_addrs__spec: req_addrs_in_range core spec_st config *)
(*     ; SimInvariant__spec_shreq_empty: _unsafe_get_field shreq "valid" (spec_st.[_mrid SHReq]) = Ob~0 *)
(*     ; SimInvariant__impl_shreq_empty: _unsafe_get_field shreq "valid" (impl_st.[_mrid SHReq]) = Ob~0 *)
(*     ; SimInvariant__impl : ImplInvariant core impl_st *)
(*     }. *)

(*   Definition custom_SimPreStepMem (core: ind_core_id) (impl_st: koika_state_t) (spec_st: koika_state_t) (config: enclave_config): Prop := *)
(*     SimInvariant core impl_st spec_st config. *)

(*   Definition _extid := ext_fn_to_debug_id. *)
(*   Definition impl_post_ext_mem_correct_core (core: ind_core_id) : fancy_spred := *)
(*     let (core_bit, turn_bits) := *)
(*       (match core with | CoreId0 => Ob~0 | CoreId1 => Ob~1 end, *)
(*        mem_core_read_turn core) in *)
(*     {{{ impl1.[_mid turn] = #turn_bits -> *)
(*         `impl_get_field (_sid mem_input) (_fld mem_input "put_valid") *)
(*           (SFinalExtLog MachineImpl (_extid ext_mainmem))` = Ob~1 -> *)
(*         `impl_get_field (_sid shreq) (_fld shreq "sourceCore") (impl_final (_mid SHReq))` = #core_bit *)
(*     }}}. *)
(*   Definition impl_purge_preserved (core: ind_core_id) *)
(*                                         (reg_init reg_final: reg_t -> sval) *)
(*                                         : fancy_spred := *)
(*     let reg_purge := _mid (purge core) in *)
(*     {{{ {`reg_init reg_purge` = #(_enum purge_state "Ready") \/ `reg_init reg_purge` = #(_enum purge_state "Purged")} -> *)
(*         `reg_final reg_purge` = `reg_init reg_purge` *)
(*     }}}. *)
(*   Definition foo_shreq_sim (core: ind_core_id) : fancy_spred := *)
(*     let turn_bits := mem_core_read_turn core in *)
(*     {{{ `impl_get_field (_sid mem_input) (_fld mem_input "put_valid") (SFinalExtLog MachineImpl (_extid ext_mainmem))` = Ob~1 -> *)
(*         impl1.[(_mid turn)] = #turn_bits -> *)
(*         impl1.[(_mid SHReq)] = spec1.[(_mid SHReq)] *)
(*     }}}. *)



(*   Record custom_SimPostStepMem (core: ind_core_id) *)
(*                                (impl_st': koika_state_t) (impl_ext: ext_log_t) *)
(*                                (spec_st': koika_state_t) (* (spec_ext: ext_log_t) *) *)
(*                                (config: enclave_config) : Prop := *)

(*     { SimPostStepMem__ext_mem_correct: *)
(*           forall core, interp_fancy_spred {| pkg_machine := impl_machine; *)
(*                                 pkg_init_st := impl_st'; *)
(*                                 pkg_sigma := fun _ _ => Failure tt; (* don't care *) *)
(*                                 pkg_mid_st := None; *)
(*                                 pkg_final_st := impl_st'; *)
(*                                 pkg_mid_ext_log := None; *)
(*                                 pkg_ext_log' := impl_ext *)
(*                              |} (impl_post_ext_mem_correct_core core) *)
(*     ; SimPostStepMem__shreq_eq: *)
(*      let turn_bits := match core with *)
(*                       | CoreId0 => (mem_core0_read_turn) *)
(*                       | CoreId1 => (mem_core1_read_turn) *)
(*                       end in *)
(*       _unsafe_get_field mem_input "put_valid" (unsafe_get_ext_call_from_log impl_ext (_ext ext_mainmem)) = Ob~1 -> *)
(*       impl_st'.[_id (_mid turn)] = turn_bits -> *)
(*       impl_st'.[_id (_mid SHReq)] = spec_st'.[_id (_mid SHReq)] *)
(*     ; customSimPost__invariant: SimInvariant core impl_st' spec_st' config *)
(*     }. *)

(*   Definition impl_ext_mem_correct_core (core: ind_core_id): fancy_spred := *)
(*     let (core_bit, turn_bits) := match core with *)
(*                                  | CoreId0 => (Ob~0, mem_core0_read_turn) *)
(*                                  | CoreId1 => (Ob~1, mem_core1_read_turn) *)
(*                                  end in *)
(*      {{{ forall1 "arg" of (unsafe_get_ext_fn_arg_type (_ext ext_mainmem)), *)
(*               `impl_get_field (_sid mem_output) (_fld mem_output "get_valid") *)
(*                 (impl_ext_app (_extid ext_mainmem) (SBound "arg"))` = Ob~1 -> *)
(*               `impl_init (_mid turn)` = #turn_bits -> *)
(*               `impl_get_field (_sid shreq) (_fld shreq "sourceCore") (impl_init (_mid SHReq))` = #core_bit *)
(*       }}}. *)
(*   Record SimPreStepMem (core: ind_core_id) *)
(*                        (impl_st: koika_state_t) *)
(*                        (spec_st: koika_state_t) *)
(*                        (impl_sigma spec_sigma: @ext_sigma_t N) *)
(*                        (config: enclave_config) *)
(*                        : Prop := *)
(*   { SimPreStepMem__turn: impl_st.[(_mrid turn)] = spec_st.[(_mrid turn)] *)
(*   ; SimPreStepMem__buffer: forall arg, *)
(*                          impl_st.[(_mrid turn)] = mem_core_read_turn core -> *)
(*                          unsafe_call_ext impl_sigma (_ext ext_mainmem) arg = *)
(*                          unsafe_call_ext spec_sigma (_ext ext_mainmem) arg /\ *)
(*                          (_unsafe_get_field mem_output "get_valid" *)
(*                             (unsafe_call_ext spec_sigma (_ext ext_mainmem) arg) = Ob~1 -> *)
(*                           impl_st.[_id (_mid SHReq)] = spec_st.[_id (_mid SHReq)] *)
(*                          ) *)
(*   ; SimPreStepMem__buffer_empty__impl: forall arg, *)
(*                                      impl_st.[_mrid turn] <> (mem_core_read_turn CoreId0) /\ *)
(*                                      impl_st.[_mrid turn] <> (mem_core_read_turn CoreId1) -> *)
(*                                      unsafe_call_ext impl_sigma (_ext ext_mainmem) arg = *)
(*                                        zeroes (Types.struct_sz mem_output) *)
(*   ; SimPreStepMem__buffer_empty__spec: forall arg, *)
(*                                      spec_st.[_mrid turn] <> (mem_core_read_turn core) -> *)
(*                                      unsafe_call_ext spec_sigma (_ext ext_mainmem) arg = *)
(*                                        zeroes (Types.struct_sz mem_output) *)
(*   ; SimPreStepMem__buffer_correct_core: forall core', interp_fancy_spred *)
(*     {| *)
(*       pkg_machine := impl_machine; *)
(*       pkg_init_st := impl_st; *)
(*       pkg_sigma := impl_sigma; *)
(*       pkg_mid_st := None; *)
(*       pkg_final_st := impl_st; (* don't care *) *)
(*       pkg_mid_ext_log := None; *)
(*       pkg_ext_log' := SortedExtFnEnv.empty (* don't care *) *)
(*     |} (impl_ext_mem_correct_core core') *)
(*   ; SimPreStepMem__custom: custom_SimPreStepMem core impl_st spec_st config *)
(*   }. *)

(*   (* smt: assert that push req is one of the valid addresses *) *)
(*   (* invariant: all valid addresses are in the config *) *)
(*   (* therefore, post step mem holds *) *)
(*   Record PostStepMem (for_impl: bool) (core: ind_core_id) *)
(*                    (st st': koika_state_t) *)
(*                    (ext: ext_log_t) *)
(*                    (config: enclave_config) *)
(*                    : Prop := *)
(*   { PostStepMem__ext_push_nonzero: *)
(*       _unsafe_get_field mem_input ("put_valid") *)
(*                        (unsafe_get_ext_call_from_log ext (_ext ext_mainmem)) = Ob~0 \/ *)
(*       st.[_id (_mid turn)] = mem_core_write_turn core \/ *)
(*       (for_impl = true /\ st.[_id (_mid turn)] = mem_core_write_turn (other_core core)) *)
(*   ; PostStepMem__other: *)
(*     st.[_id (_mid turn)] = mem_core_write_turn (other_core core) -> *)
(*     match *)
(*       get_valid_addr_from_push_req *)
(*         (unsafe_get_ext_call_from_log ext (_ext ext_mainmem)) *)
(*     with *)
(*     | Some addr => mem_addr_in_option_config EnclaveParams.enclave_sig addr (Some config) -> False *)
(*     | None => True *)
(*     end *)
(*   ; PostStepMem__ext_led : SortedExtFnEnv.opt_get ext (_ext ext_led) = None *)
(*   ; PostStepMem__ext_uart_read: SortedExtFnEnv.opt_get ext (_ext ext_uart_read) = None *)
(*   ; PostStepMem__ext_uart_write: SortedExtFnEnv.opt_get ext (_ext ext_uart_write) = None *)
(*   ; PostStepMem__addr_in_config: req_addrs_in_range core st' config *)
(*   ; PostStepMem__spec: for_impl = false -> *)
(*                      forall reg, (In reg *)
(*                                 ([_mrid turn; _mrid SHReq; _mrid SHResp] ++ (map _rid ((private_mem_regs core) ++ (ext_mem_regs core)))) -> False) -> *)
(*                               st.[reg] = st'.[reg] *)
(*   ; PostStepMem__impl: for_impl = true -> *)
(*                      forall reg, ((In reg (map _rid memory_regs)) -> False) -> *)
(*                               st.[reg] = st'.[reg] *)
(*   ; PostStepMem__no_new_reqs_impl: for_impl = true -> *)
(*       forall core, interp_fancy_spred {| pkg_machine := impl_machine; *)
(*                                    pkg_init_st := st; *)
(*                                    pkg_sigma := fun (_ : ext_fn_t) (_ : list bool) => Failure tt; *)
(*                                    pkg_mid_st := None; *)
(*                                    pkg_final_st := st'; *)
(*                                    pkg_mid_ext_log := None; *)
(*                                    pkg_ext_log' := ext *)
(*                                  |} (impl_post_ext_mem_correct_core core); *)
(*   }. *)

(*   Record SimPostStepMem (core: ind_core_id) *)
(*                       impl_st (impl_sigma: @ext_sigma_t  N) (impl_st': koika_state_t) (impl_ext: ext_log_t) *)
(*                       spec_st (spec_sigma: @ext_sigma_t N) (spec_st': koika_state_t) (spec_ext: ext_log_t) *)
(*                       (config: enclave_config) *)
(*                       : Prop := *)
(*   { SimPostStepMem__push_sim: (* technically only need to guarantee if  request is valid *) *)
(*     impl_st.[(_mrid turn)] = mem_core_write_turn core -> *)
(*     unsafe_get_ext_call_from_log impl_ext ((_ext ext_mainmem)) = *)
(*     unsafe_get_ext_call_from_log spec_ext ((_ext ext_mainmem)) *)
(*   ; SimPostStepMem__impl: PostStepMem true core impl_st impl_st' impl_ext config *)
(*   ; SimPostStepMem__spec: PostStepMem false core spec_st spec_st' spec_ext config *)
(*     ; SimPostStepMem__purge_preserved: *)
(*           forall core, interp_fancy_spred {| pkg_machine := impl_machine; *)
(*                                 pkg_init_st := impl_st; *)
(*                                 pkg_sigma := fun _ _ => Failure tt; (* don't care *) *)
(*                                 pkg_mid_st := None; *)
(*                                 pkg_final_st := impl_st'; *)
(*                                 pkg_mid_ext_log := None; *)
(*                                 pkg_ext_log' := impl_ext *)
(*                              |} (impl_purge_preserved core impl_init impl_final) *)

(*   ; SimPostStepMem__custom: custom_SimPostStepMem core impl_st' impl_ext spec_st' (* spec_ext *) config *)
(*   }. *)


(* (* write turn -> mem_output write -> shreq related *) *)
(* (* H: get_field (dstruct_fields mem_input) (_fld mem_input "put_valid") *) *)
(* (*             (unsafe_get_ext_call_from_log (Log__ext log) (_extid ext_mainmem)) =  *) *)
(* (*           Success Ob~1 *) *)
(*   (* Goal: SHREQ (commit_update (machine_koika_st impl_st) (Log__koika log)).[212%N] = (machine_koika_st machine_st').[212%N] *) *)

(*   (* Notation "'interp_machine' '(' sigma ')' state" := (interp_scheduler sigma *) *)
(*   (*                (id_transform_int_fn_env _id Memory.int_fns) *) *)
(*   (*                (id_transform_struct_env _id Memory.struct_defs) (state) *) *)
(*   (*                (fun rl : memory_rule_name_t => id_transform_action snd (Memory.rules rl))) (at level 1). *) *)

(*   Lemma schedule_oraat_ok: *)
(*     oraat_ok id_int_fns id_rules (list_of_schedule Impl.mem_schedule) = true. *)
(*   Proof. *)
(*     vm_compute. reflexivity. *)
(*   Qed. *)

(*   Lemma schedule_oraat_ok_spec0: *)
(*     oraat_ok id_int_fns id_rules (map Machine.RlMem (list_of_schedule (mem_schedule CoreId0))) = true. *)
(*   Proof. *)
(*     vm_compute. reflexivity. *)
(*   Qed. *)

(*   Lemma schedule_oraat_ok_spec1: *)
(*     oraat_ok id_int_fns id_rules (map Machine.RlMem (list_of_schedule (mem_schedule CoreId1))) = true. *)
(*   Proof. *)
(*     vm_compute. reflexivity. *)
(*   Qed. *)



(*   Inductive custom_prop_names := *)
(*   | CP_sim_regs *)
(*   | CP_impl_shreq_invalid *)
(*   | CP_spec_shreq_invalid *)
(*   | CP_sim_mem_response *)
(*   | CP_sim_shreq *)
(*   | CP_impl_mem_empty *)
(*   | CP_spec_mem_empty *)
(*   | CP_impl_mem_correct_core0 *)
(*   | CP_impl_mem_correct_core1 *)
(*   | CP_push_sim *)
(*   | CP_impl_push_zero *)
(*   | CP_spec_push_zero *)
(*   | CP_impl_push_in_range0 *)
(*   | CP_impl_push_in_range1 *)
(*   | CP_spec_push_in_range *)
(*   | CP_ImplInvariant *)
(*   | CP_impl_addr_preserve0 *)
(*   | CP_impl_addr_preserve1 *)
(*   | CP_spec_addr_preserve *)
(*   | CP_impl_purged0 *)
(*   | CP_impl_purged1 *)
(*   | CP_post_ext_mem_core0 *)
(*   | CP_post_ext_mem_core1 *)
(*   | CP_purge_preserve0 *)
(*   | CP_purge_preserve1 *)
(*   | CP_shreq_write_sim *)
(*  . *)

(*   Definition foo_ImplInvariant (core: ind_core_id) (impl_reg: reg_t -> sval) : list (custom_prop_names * fancy_spred) := *)
(*     [(CP_impl_shreq_invalid, {{{ `impl_get_field (_sid shreq) (_fld shreq "valid") (impl_reg (_mid SHReq))` = Ob~0 }}}) *)
(*     ;(CP_impl_purged0, foo_reset_correct CoreId0 impl_reg impl_get_field) *)
(*     ;(CP_impl_purged1, foo_reset_correct CoreId1 impl_reg impl_get_field) *)
(*     ]. *)

(*   Definition foo_SimInvariant (core: ind_core_id) (impl_reg: reg_t -> sval) (spec_reg: reg_t -> sval) *)
(*     : list (custom_prop_names * fancy_spred) := *)
(*     [(CP_sim_regs, {{{ forall x in ([_mid turn] ++ (map reg_to_debug_id ((private_mem_regs core) ++ (ext_mem_regs core)))), *)
(*                   `impl_reg x` = `spec_reg x` *)
(*               }}} *)
(*      ) *)
(*     ;(CP_spec_shreq_invalid, {{{ `spec_get_field (_sid shreq) (_fld shreq "valid") (spec_reg (_mid SHReq))` = Ob~0 }}}) *)
(*     ]. *)



(*   Definition foo_req_in_fifo (req: sval) (reg_fn: reg_t -> sval) (reg_data: reg_t) (reg_valid: reg_t) : fancy_spred := *)
(*     {{{ `reg_fn reg_valid` = Ob~1 /\ *)
(*         (* `addr` = `get_field mem_req.(sid) FLD_mem_req__addr (reg_fn reg_data)` *) *)
(*         `req` = `reg_fn reg_data` *)
(*     }}}. *)

(*   Definition push_in_range (core: ind_core_id) (reg_init: reg_t -> sval) (ext_log: debug_id_ty -> sval) machine_id : fancy_spred := *)
(*     let get_field := *)
(*       match machine_id with *)
(*       | MachineImpl => impl_get_field *)
(*       | MachineSpec => spec_get_field *)
(*       end in *)
(*     let reg_priv_turn := _mid (priv_turn core) in *)
(*     let push_req := *)
(*         get_field (_sid mem_input) (_fld mem_input "put_request") (ext_log (_extid ext_mainmem)) in *)
(*     (* let addr := get_field mem_req.(sid) FLD_mem_req__addr push_req in *) *)
(*     let (to_imem_data, to_imem_valid) := ((Memory.toIMem core) MemReq.data0, (Memory.toIMem core) MemReq.valid0) in *)
(*     let (to_dmem_data, to_dmem_valid) := ((Memory.toDMem core) MemReq.data0, (Memory.toDMem core) MemReq.valid0) in *)
(*     {{{ `reg_init (_mid turn)` = #(mem_core_write_turn core) -> *)
(*         `get_field (_sid mem_input) (_fld mem_input "put_valid") (ext_log (_extid ext_mainmem))` = Ob~1 -> *)
(*         { `reg_init reg_priv_turn` = Ob~1 -> ``foo_req_in_fifo push_req reg_init (_mid to_imem_data)  (_mid to_imem_valid) ``} /\ *)
(*         { `reg_init reg_priv_turn` = Ob~0 -> ``foo_req_in_fifo push_req reg_init (_mid to_dmem_data) (_mid to_dmem_valid) ``} *)
(*     }}}. *)
(*   Definition fifo_no_new_reqs (reg_init reg_final: reg_t -> sval) (reg_data reg_valid: reg_t) : fancy_spred := *)
(*     {{{ `reg_final reg_valid` = Ob~1 -> *)
(*         `reg_init reg_valid` = Ob~1 /\ *)
(*         `reg_init reg_data` = `reg_final reg_data` *)
(*         (* `get_field mem_req.(sid) FLD_mem_req__addr (reg_init reg_data)` = *) *)
(*         (* `get_field mem_req.(sid) FLD_mem_req__addr (reg_final reg_data)` *) *)
(*     }}}. *)
(*   Definition no_new_reqs (core: ind_core_id) mid : fancy_spred := *)
(*     let reg_init := mk_init_reg mid in *)
(*     let reg_final := mk_final_reg mid in *)
(*     let (to_imem_data, to_imem_valid) := ((Memory.toIMem core) MemReq.data0, (Memory.toIMem core) MemReq.valid0) in *)
(*     let (to_dmem_data, to_dmem_valid) := ((Memory.toDMem core) MemReq.data0, (Memory.toDMem core) MemReq.valid0) in *)
(*     {{{ ``fifo_no_new_reqs reg_init reg_final (_mid to_imem_data) (_mid to_imem_valid)`` /\ *)
(*         ``fifo_no_new_reqs reg_init reg_final (_mid to_dmem_data) (_mid to_dmem_valid) `` *)
(*     }}}. *)

(*   Definition foo_SimPreStepMem (core: ind_core_id) : list (custom_prop_names * fancy_spred) := *)
(*     [(CP_sim_mem_response, *)
(*        {{{ forall1 "arg" of (unsafe_get_ext_fn_arg_type (_ext ext_mainmem)), *)
(*              `impl_init (_mid turn)` = #(mem_core_read_turn core) -> *)
(*              `impl_ext_app (_extid ext_mainmem) (SBound "arg")` = `spec_ext_app (_extid ext_mainmem) (SBound "arg")` /\ *)
(*                { `spec_get_field (_sid mem_output) (_fld mem_output "get_valid") (spec_ext_app (_extid ext_mainmem) (SBound "arg"))` = Ob~1 -> *)
(*                  `impl_init (_mid SHReq)` = `spec_init (_mid SHReq)` *)
(*                } *)
(*        }}}) *)
(*      ;(CP_impl_mem_empty, *)
(*         {{{ forall1 "arg" of (unsafe_get_ext_fn_arg_type (_ext ext_mainmem)), *)
(*               {`impl_init (_mid turn)` <> #(mem_core_read_turn CoreId0) /\ *)
(*                `impl_init (_mid turn)` <> #(mem_core_read_turn CoreId1)} -> *)
(*               `impl_ext_app (_extid ext_mainmem) (SBound "arg")` = #(zeroes (Types.struct_sz mem_output)) *)
(*         }}} *)
(*       ) *)
(*      ;(CP_spec_mem_empty, *)
(*         {{{ forall1 "arg" of (unsafe_get_ext_fn_arg_type (_ext ext_mainmem)), *)
(*               `spec_init (_mid turn)` <> #(mem_core_read_turn core) -> *)
(*               `spec_ext_app (_extid ext_mainmem) (SBound "arg")` = #(zeroes (Types.struct_sz mem_output)) *)
(*         }}} *)
(*       ) *)
(*      ;(CP_impl_mem_correct_core0,  impl_ext_mem_correct_core CoreId0) *)
(*      ;(CP_impl_mem_correct_core1, impl_ext_mem_correct_core CoreId1) *)
(*     ] ++ *)
(*     (foo_SimInvariant core impl_init spec_init) ++ (foo_ImplInvariant core impl_init). *)


(*   Definition foo_SimPostStepMem (core: ind_core_id) : list (custom_prop_names * fancy_spred) := *)
(*     [(CP_push_sim, {{{ impl0.[(_mid turn)] = #(mem_core_write_turn core) -> (* read/write? *) *)
(*                        impl_ext1.[(_extid ext_mainmem)] = *)
(*                        spec_ext1.[(_extid ext_mainmem)] *)
(*                    }}}) *)
(*     ;(CP_impl_push_zero, {{{ `impl_get_field (_sid mem_input) (_fld mem_input "put_valid") *)
(*                                   (SFinalExtLog MachineImpl (_extid ext_mainmem))` = Ob~0 \/ *)
(*                               impl0.[(_mid turn)] = #(mem_core_write_turn CoreId0) \/ *)
(*                               impl0.[(_mid turn)] = #(mem_core_write_turn CoreId1) *)
(*                           }}}) *)
(*     ;(CP_spec_push_zero, {{{ `spec_get_field (_sid mem_input) (_fld mem_input "put_valid") *)
(*                                   (SFinalExtLog MachineSpec (_extid ext_mainmem))` = Ob~0 \/ *)
(*                               spec0.[(_mid turn)] = #(mem_core_write_turn core) *)
(*                           }}}) *)
(*      ;(CP_spec_push_in_range, push_in_range core spec_init spec_final_ext MachineSpec) *)
(*      ;(CP_impl_push_in_range0, push_in_range CoreId0 impl_init impl_final_ext MachineImpl) (* performance! *) *)
(*      ;(CP_impl_push_in_range1, push_in_range CoreId1 impl_init impl_final_ext MachineImpl) *)
(*      ;(CP_impl_addr_preserve0, no_new_reqs CoreId0 MachineImpl) *)
(*      ;(CP_impl_addr_preserve1, no_new_reqs CoreId1 MachineImpl) *)
(*      ;(CP_spec_addr_preserve, no_new_reqs core MachineSpec) *)
(*      ;(CP_post_ext_mem_core0, impl_post_ext_mem_correct_core CoreId0) *)
(*      ;(CP_post_ext_mem_core1, impl_post_ext_mem_correct_core CoreId1) *)
(*      ;(CP_purge_preserve0, impl_purge_preserved CoreId0 impl_init impl_final) *)
(*      ;(CP_purge_preserve1, impl_purge_preserved CoreId1 impl_init impl_final) *)
(*      ;(CP_shreq_write_sim, foo_shreq_sim core) *)
(*     ] ++ *)
(*     foo_SimInvariant core impl_final spec_final ++ (foo_ImplInvariant core impl_final). *)

(*   Definition SimPreStepMem' (core: ind_core_id) *)
(*                        (impl_st: state_t) (impl_sigma: @ext_sigma_t N) (impl_st': koika_state_t) (impl_ext: ext_log_t) *)
(*                        (spec_st: state_t) (spec_sigma: @ext_sigma_t N) (spec_st': koika_state_t) (spec_ext: ext_log_t) *)
(*                        (config: enclave_config) : Prop := *)
(*     let impl_pkg := {| pkg_machine := impl_machine; *)
(*                        pkg_init_st := impl_st; *)
(*                        pkg_sigma := impl_sigma; *)
(*                        pkg_mid_st := None; *)
(*                        pkg_final_st := impl_st'; *)
(*                        pkg_mid_ext_log := None; *)
(*                        pkg_ext_log' := impl_ext |} in *)
(*     let spec_pkg := {| pkg_machine := spec0_machine; *)
(*                        pkg_init_st := spec_st; *)
(*                        pkg_sigma := spec_sigma; *)
(*                        pkg_mid_st := None; *)
(*                        pkg_final_st := spec_st'; *)
(*                        pkg_mid_ext_log := None; *)
(*                        pkg_ext_log' := spec_ext |} in *)
(*     Forall (fun '(_, p) => interp_fancy_spred2 impl_pkg spec_pkg p) (foo_SimPreStepMem core). *)
(*   Definition SimPostStepMem' (core: ind_core_id) *)
(*                        (impl_st: state_t) (impl_sigma: @ext_sigma_t N) (impl_st': koika_state_t) (impl_ext: ext_log_t) *)
(*                        (spec_st: state_t) (spec_sigma: @ext_sigma_t N) (spec_st': koika_state_t) (spec_ext: ext_log_t) *)
(*                        (init_config: enclave_config) : Prop := *)
(*     let impl_pkg := {| pkg_machine := impl_machine; *)
(*                        pkg_init_st := impl_st; *)
(*                        pkg_sigma := impl_sigma; *)
(*                        pkg_mid_st := None; *)
(*                        pkg_final_st := impl_st'; *)
(*                        pkg_mid_ext_log := None; *)
(*                        pkg_ext_log' := impl_ext |} in *)
(*     let spec_pkg := {| pkg_machine := spec0_machine; *)
(*                        pkg_init_st := spec_st; *)
(*                        pkg_sigma := spec_sigma; *)
(*                        pkg_mid_st := None; *)
(*                        pkg_final_st := spec_st'; *)
(*                        pkg_mid_ext_log := None; *)
(*                        pkg_ext_log' := spec_ext |} in *)
(*     (forall reg : N, (In reg (map _rid (memory_regs)) -> False) -> impl_st.[reg] = impl_st'.[reg]) /\ *)
(*     (forall reg : N, *)
(*         (In reg ([_mrid turn; _mrid SHReq; _mrid SHResp] ++ (map _rid ((private_mem_regs core) ++ (ext_mem_regs core)))) -> False) -> *)
(*         spec_st.[reg] = spec_st'.[reg]) /\ *)
(*     SortedExtFnEnv.opt_get impl_ext (_ext ext_led) = None /\ *)
(*     SortedExtFnEnv.opt_get impl_ext (_ext ext_uart_read) = None /\ *)
(*     SortedExtFnEnv.opt_get impl_ext (_ext ext_uart_write) = None /\ *)
(*     SortedExtFnEnv.opt_get spec_ext (_ext ext_led) = None /\ *)
(*     SortedExtFnEnv.opt_get spec_ext (_ext ext_uart_read) = None /\ *)
(*     SortedExtFnEnv.opt_get spec_ext (_ext ext_uart_write) = None /\ *)
(*     Forall (fun '(_, p) => interp_fancy_spred2 impl_pkg spec_pkg p) (foo_SimPostStepMem core). *)
(*   Parameter smt_sim0_correct: *)
(*     symbolic_evaluate_file_success_product *)
(*       impl_machine spec0_machine impl_schedule spec0_schedule *)
(*         (preprocess_fancy_spreds (foo_SimPreStepMem CoreId0)) *)
(*         (preprocess_fancy_spreds (foo_SimPostStepMem CoreId0)). *)

(*   Lemma TEST_interp_mem_sim0: *)
(*    sim_interp_scheduler_satisfies_spec *)
(*      reg_type_env _ext_fn_tys *)
(*      id_int_fns id_int_fns *)
(*      id_struct_defs id_struct_defs *)
(*      id_rules id_rules *)
(*      Impl.mem_schedule (map_scheduler Machine.RlMem (mem_schedule CoreId0)) enclave_config *)
(*      (fun impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost => *)
(*         SimPreStepMem' CoreId0 impl_st impl_sigma impl_st' impl_ext *)
(*                                spec_st spec_sigma spec_st' spec_ext ghost) *)
(*      (SimPostStepMem' CoreId0). *)
(*   Proof. *)
(*     unfold sim_interp_scheduler_satisfies_spec. *)
(*     intros * hwf_impl hwf_spec hwf_impl_sigma hwf_spec_sigma hwf_impl_fns hwf_spec_fns *)
(*              himpl_step hspec_step hpre. *)
(*     specialize typecheck_scheduler_correct'' with (5 := himpl_step) (2 := hwf_impl) (3 := hwf_impl_sigma) (4 := hwf_impl_fns) (1 := eq_refl). intros (hwf_impl' & wf_impl_ext'). *)
(*     specialize typecheck_scheduler_correct'' with (5 := hspec_step) (2 := hwf_spec) (3 := hwf_spec_sigma) (4 := hwf_spec_fns) (1 := eq_refl). intros (hwf_spec' & wf_spec_ext'). *)
(*     split_ands_in_goal; auto. *)
(*     unfold SimPostStepMem'. *)
(*     unfold SimPreStepMem' in *. propositional. *)
(*     assert (SortedExtFnEnv.opt_get (Log__ext impl_log) (_ext ext_led) = None) as himpl_ext_led. *)
(*     { eapply ext_fn_taint_schedule_empty_correct_fn with (2 := himpl_step). vm_compute. reflexivity. } *)
(*     assert (SortedExtFnEnv.opt_get (Log__ext impl_log) (_ext ext_uart_read) = None) as himpl_ext_uart_read. *)
(*     { eapply ext_fn_taint_schedule_empty_correct_fn with (2 := himpl_step). vm_compute. reflexivity. } *)
(*     assert (SortedExtFnEnv.opt_get (Log__ext impl_log) (_ext ext_uart_write) = None) as himpl_ext_uart_write. *)
(*     { eapply ext_fn_taint_schedule_empty_correct_fn with (2 := himpl_step). vm_compute. reflexivity. } *)
(*     assert (SortedExtFnEnv.opt_get (Log__ext spec_log) (_ext ext_led) = None) as hspec_ext_led. *)
(*     { eapply ext_fn_taint_schedule_empty_correct_fn with (2 := hspec_step). vm_compute. reflexivity. } *)
(*     assert (SortedExtFnEnv.opt_get (Log__ext spec_log) (_ext ext_uart_read) = None) as hspec_ext_uart_read. *)
(*     { eapply ext_fn_taint_schedule_empty_correct_fn with (2 := hspec_step). vm_compute. reflexivity. } *)
(*     assert (SortedExtFnEnv.opt_get (Log__ext spec_log) (_ext ext_uart_write) = None) as hspec_ext_uart_write. *)
(*     { eapply ext_fn_taint_schedule_empty_correct_fn with (2 := hspec_step). vm_compute. reflexivity. } *)

(*     eapply oraat_interp_scheduler__conflicts_correct with *)
(*       (1 := strong_WF_state_weaken _ _ hwf_impl) *)
(*       (5 := schedule_oraat_ok) in himpl_step; eauto. *)
(*     eapply oraat_interp_scheduler__conflicts_correct with *)
(*       (1 := strong_WF_state_weaken _ _ hwf_spec) *)
(*       (5 := schedule_oraat_ok_spec0) in hspec_step; eauto. *)

(*     split_ands_in_goal; auto; try assumption. *)
(*     - eapply taint_safety_schedule in himpl_step; [ | vm_compute; reflexivity]. *)
(*       intros. symmetry. *)
(*       specialize (check_regs_outside_reg_set_untainted_correct) with *)
(*         (int_fns := id_int_fns) *)
(*         (rules := id_rules) *)
(*         (schedule := Impl.mem_schedule) (regs := (map _rid memory_regs)) (1 := eq_refl). *)
(*       intros (env & htaint & hin). *)
(*       eapply taint_set_to_prop_no_write'. *)
(*       2: { eapply forall_regs_no_writes_exclude. eapply hin. apply H. } *)
(*       rewrite<-htaint. apply himpl_step. *)
(*     - apply taint_safety_schedule in hspec_step; [ | vm_compute; reflexivity]. *)
(*       intros. symmetry. *)
(*       specialize (check_regs_outside_reg_set_untainted_correct) with *)
(*         (int_fns := id_int_fns) *)
(*         (rules := id_rules) *)
(*         (schedule := (map_scheduler Machine.RlMem (mem_schedule CoreId0))) *)
(*         (regs := ([_mrid turn; _mrid SHReq; _mrid SHResp] ++ (map _rid ((private_mem_regs CoreId0) ++ (ext_mem_regs CoreId0))))) *)
(*         (1 := eq_refl). *)
(*       intros (env & htaint & hin). *)
(*       eapply taint_set_to_prop_no_write'. *)
(*       2: { eapply forall_regs_no_writes_exclude. eapply hin. apply H. } *)
(*       rewrite<-htaint. apply hspec_step. *)
(*     - rewrite<-forall_preprocess_fancy_spreds_correct2. *)
(*       apply smt_sim0_correct. *)
(*       + rewrite forall_preprocess_fancy_spreds_correct2. *)
(*         auto. *)
(*       (* + rewrite Forall_interp_fancy2_rewrite. auto. *) *)
(*       + unfold machine_to_prop. split_ands_in_goal. *)
(*         * auto. *)
(*         * apply strong_WF_state_weaken in hwf_impl. *)
(*           eapply WF_state_subset with (2 := hwf_impl). vm_compute. reflexivity. *)
(*         * rewrite<-himpl_step. rewrite<-oraat_interp_scheduler_list_iff. *)
(*           symmetry. eapply oraat_interp_scheduler_list_expand. *)
(*           replace (list_of_schedule Impl.mem_schedule) with (map fst (impl_schedule_list)) by reflexivity. *)
(*           apply @Forall2_rules_equiv_preprocess. vm_compute. reflexivity. *)
(*       + unfold machine_to_prop. split_ands_in_goal. *)
(*         * auto. *)
(*         * apply strong_WF_state_weaken in hwf_spec. *)
(*           eapply WF_state_subset with (2 := hwf_spec). vm_compute. reflexivity. *)
(*         * rewrite<-hspec_step. rewrite<-oraat_interp_scheduler_list_iff. *)
(*           symmetry. eapply oraat_interp_scheduler_list_expand. *)
(*           replace (list_of_schedule (map_scheduler Machine.RlMem (mem_schedule CoreId0))) *)
(*             with (map fst (spec0_schedule_list)) by reflexivity. *)
(*           apply @Forall2_rules_equiv_preprocess. vm_compute. reflexivity. *)
(*   Qed. *)

(*   Lemma SimPreStepMem'_implies: *)
(*     forall core impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost, *)
(*       WF_state (SortedRegEnv.to_list reg_type_env) impl_st -> *)
(*       WF_state (SortedRegEnv.to_list reg_type_env) spec_st -> *)
(*       (* unsafe_enclave_data_to_config impl_st.[_id (SM.lookup_reg_enc_data core)] = ghost-> *) *)
(*       SimPreStepMem core impl_st spec_st impl_sigma spec_sigma ghost -> *)
(*       SimPreStepMem' core impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost. *)
(*   Proof. *)
(*     intros * hwf_impl hwf_spec hpre. *)
(*     constructor. *)
(*     - specialize SimPreStepMem__buffer with (1 := hpre); auto. *)
(*     - destruct hpre. consider custom_SimPreStepMem. *)
(*       destruct SimPreStepMem__custom0.  destruct SimInvariant__impl0. *)
(*       constructor; auto. *)
(*       constructor; auto. *)
(*       constructor; auto. *)
(*       { rewrite interp_fancy_spred2_using_impl_only by auto. *)
(*         rewrite interp_fancy_spred_ignores_final_st by auto. *)
(*         rewrite interp_fancy_spred_ignores_ext_log by auto. *)
(*         eauto. *)
(*       } *)
(*       constructor; auto. *)
(*       { rewrite interp_fancy_spred2_using_impl_only by auto. *)
(*         rewrite interp_fancy_spred_ignores_final_st by auto. *)
(*         rewrite interp_fancy_spred_ignores_ext_log by auto. *)
(*         eauto. *)
(*       } *)
(*       constructor; auto. *)
(*       constructor; auto. *)
(*       constructor; auto. *)
(*   Qed. *)
(* Lemma discharge_and_left: *)
(*   forall (x: Prop) y, *)
(*   x -> *)
(*   x /\ y <-> y. *)
(* Proof. *)
(*   split; auto. propositional. *)
(* Qed. *)
(* Lemma fifo_addrs_in_range_preserved: *)
(*   forall ghost mid pkg reg_valid reg_data, *)
(*   fifo_addrs_in_range EnclaveParams.enclave_sig (pkg_init_st pkg) ghost (_id reg_valid) (_id reg_data) -> *)
(*   interp_fancy_spred' pkg [] (fifo_no_new_reqs (mk_init_reg mid) (mk_final_reg mid) reg_data reg_valid) -> *)
(*   fifo_addrs_in_range EnclaveParams.enclave_sig (pkg_final_st pkg) ghost (_id reg_valid) (_id reg_data). *)
(* Proof. *)
(*   intros * hfifo hinterp. subst. *)
(*   consider fifo_addrs_in_range. consider mem_addr_in_option_config. *)
(*   consider addr_in_config. cbn in hinterp. propositional. *)
(*   exists region. *)
(*   setoid_rewrite hinterp1 in hfifo1. auto. *)
(* Qed. *)
(* Lemma fifo_addrs_not_in_range_preserved: *)
(*   forall ghost mid pkg reg_valid reg_data, *)
(*   fifo_addrs_not_in_range EnclaveParams.enclave_sig (pkg_init_st pkg) ghost (_id reg_valid) (_id reg_data) -> *)
(*   interp_fancy_spred' pkg [] (fifo_no_new_reqs (mk_init_reg mid) (mk_final_reg mid) reg_data reg_valid ) -> *)
(*   fifo_addrs_not_in_range EnclaveParams.enclave_sig (pkg_final_st pkg) ghost (_id reg_valid) (_id reg_data). *)
(* Proof. *)
(*   intros * hfifo hinterp. subst. *)
(*   consider fifo_addrs_not_in_range. consider mem_addr_in_option_config. *)
(*   consider addr_in_config. cbn in hinterp. propositional. *)
(*   apply hfifo. *)
(*   exists region. *)
(*   setoid_rewrite hinterp1. auto. *)
(* Qed. *)

(* Lemma req_addrs_in_range_preserved: *)
(*   forall core st st' ghost mid pkg, *)
(*   req_addrs_in_range core st ghost -> *)
(*   pkg.(pkg_init_st) = st -> *)
(*   pkg.(pkg_final_st) = st' -> *)
(*   pkg.(pkg_machine).(file_struct_defs) = struct_defs -> *)
(*   interp_fancy_spred pkg (no_new_reqs core mid) -> *)
(*   req_addrs_in_range core st' ghost. *)
(* Proof. *)
(*   intros * hreq ? ? ? hpred. subst. *)
(*   consider no_new_reqs. consider interp_fancy_spred. *)
(*   consider req_addrs_in_range. *)
(*   destruct core; propositional; *)
(*     rewrite interp_fancy_spred'_PBase in *; *)
(*     rewrite interp_spred'_PAnd in *; *)
(*     repeat rewrite interp_spred'_PFancy in *; *)
(*     destruct hpred as (hpredi & hpredd). *)
(*   - split; eapply fifo_addrs_in_range_preserved with (mid := mid); eauto. *)
(*   - split; eapply fifo_addrs_in_range_preserved with (mid := mid); eauto. *)
(* Qed. *)


(* Lemma push_other_core_not_in_range_preserved: *)
(*   forall pkg core impl_st impl_ext config, *)
(*   WF_state (SortedRegEnv.to_list reg_type_env) impl_st -> *)
(*   req_addrs_not_in_range (other_core core) impl_st config -> *)
(*   interp_fancy_spred pkg (push_in_range (other_core core) impl_init impl_final_ext MachineImpl) -> *)
(*   pkg.(pkg_init_st) = impl_st -> *)
(*   pkg.(pkg_ext_log') = impl_ext -> *)
(*   pkg.(pkg_machine).(file_struct_defs) = struct_defs -> *)
(*   impl_st.[_id (_mid turn)] = mem_core_write_turn (other_core core) -> *)
(*   match get_valid_addr_from_push_req (unsafe_get_ext_call_from_log impl_ext (_ext ext_mainmem)) with *)
(*   | Some addr => mem_addr_in_option_config EnclaveParams.enclave_sig addr (Some config) -> False *)
(*   | None => True *)
(*   end. *)
(* Proof. *)
(*   intros * hwf hreq hinterp hinit hext hstructs hwrite. *)
(*   assert (Datatypes.length impl_st.[_mrid (priv_turn (other_core core))] = 1) as hlen_priv. *)
(*   { eapply WF_state_length; eauto. destruct core; reflexivity. } *)

(*   destruct core. *)
(*   - cbn in hinterp. propositional. *)
(*     consider req_addrs_not_in_range. simpl in hreq. propositional. *)
(*     consider fifo_addrs_not_in_range. *)
(*     split_cases. *)
(*     destruct_match; auto. *)
(*     consider get_valid_addr_from_push_req. *)
(*     bash_destruct Heqo. simplify. *)
(*     rewrite hstructs in *. *)
(*     assert_pre_and_specialize hinterp. *)
(*     { eapply _get_field_implies_unsafe_get_field; eauto. } *)
(*     destruct hinterp as (hinterp_imem & hinterp_dmem); propositional; auto. *)
(*     destruct (case_singleton_bv _ hlen_priv) as [hcase | hcase]; simpl in hcase; propositional. *)
(*     + rewrite _get_field_implies_unsafe_get_field with (1 := Heqr1) in hinterp_imem1 by reflexivity. *)
(*       propositional. *)
(*       setoid_rewrite _get_field_implies_unsafe_get_field with (1 := Heqr2) in hreq0; auto. *)
(*     + rewrite _get_field_implies_unsafe_get_field with (1 := Heqr1) in hinterp_dmem1 by reflexivity. *)
(*       propositional. *)
(*       setoid_rewrite _get_field_implies_unsafe_get_field with (1 := Heqr2) in hreq1; auto. *)
(*   - cbn in hinterp. propositional. *)
(*     consider req_addrs_not_in_range. simpl in hreq. propositional. *)
(*     consider fifo_addrs_not_in_range. *)
(*     split_cases. *)
(*     destruct_match; auto. *)
(*     consider get_valid_addr_from_push_req. *)
(*     bash_destruct Heqo. simplify. *)
(*     rewrite hstructs in *. *)
(*     assert_pre_and_specialize hinterp. *)
(*     { eapply _get_field_implies_unsafe_get_field; eauto. } *)
(*     destruct hinterp as (hinterp_imem & hinterp_dmem); propositional; auto. *)
(*     destruct (case_singleton_bv _ hlen_priv) as [hcase | hcase]; simpl in hcase; propositional. *)
(*     + rewrite _get_field_implies_unsafe_get_field with (1 := Heqr1) in hinterp_imem1 by reflexivity. *)
(*       propositional. *)
(*       setoid_rewrite _get_field_implies_unsafe_get_field with (1 := Heqr2) in hreq0; auto. *)
(*     + rewrite _get_field_implies_unsafe_get_field with (1 := Heqr1) in hinterp_dmem1 by reflexivity. *)
(*       propositional. *)
(*       setoid_rewrite _get_field_implies_unsafe_get_field with (1 := Heqr2) in hreq1; auto. *)
(* Qed. *)
(* Lemma req_addrs_not_in_range_preserved: *)
(*   forall core st st' ghost mid pkg, *)
(*   req_addrs_not_in_range core st ghost -> *)
(*   pkg.(pkg_init_st) = st -> *)
(*   pkg.(pkg_final_st) = st' -> *)
(*   pkg.(pkg_machine).(file_struct_defs) = struct_defs -> *)
(*   interp_fancy_spred pkg (no_new_reqs core mid) -> *)
(*   req_addrs_not_in_range core st' ghost. *)
(* Proof. *)
(*   intros * hreq ? ? ? hpred. subst. *)
(*   consider no_new_reqs. consider interp_fancy_spred. *)
(*   consider req_addrs_not_in_range. *)
(*   destruct core; propositional; *)
(*     rewrite interp_fancy_spred'_PBase in *; *)
(*     rewrite interp_spred'_PAnd in *; *)
(*     repeat rewrite interp_spred'_PFancy in *; *)
(*     destruct hpred as (hpredi & hpredd). *)
(*   - split; eapply fifo_addrs_not_in_range_preserved with (mid := mid); eauto. *)
(*   - split; eapply fifo_addrs_not_in_range_preserved with (mid := mid); eauto. *)
(* Qed. *)

(*   Lemma SimPostStepMem'_implies: *)
(*     forall core impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost, *)
(*     WF_state (SortedRegEnv.to_list reg_type_env) impl_st -> *)
(*     WF_state (SortedRegEnv.to_list reg_type_env) spec_st -> *)
(*     WF_state (SortedRegEnv.to_list reg_type_env) impl_st' -> *)
(*     WF_state (SortedRegEnv.to_list reg_type_env) spec_st' -> *)
(*     req_addrs_in_range core impl_st ghost -> *)
(*     req_addrs_in_range core spec_st ghost -> *)
(*     req_addrs_not_in_range (other_core core) impl_st ghost -> *)
(*     SimPostStepMem' core impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost -> *)
(*     SimPostStepMem core impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost. *)
(*   Proof. *)
(*     intros * hwf_impl hwf_spec hwf_impl' hwf_spec' himpl_ghost hspec_ghost himpl_ghost'. *)
(*     consider SimPostStepMem'. *)
(*     intros (hi_nowrite & hs_nowrite & hi_led & hi_uread & hi_uwrite & hs_led & hs_uread & hs_uwrite & Hfoo). *)
(*     assert (req_addrs_in_range core impl_st' ghost) as himpl_req'. *)
(*     { eapply req_addrs_in_range_preserved with (1 := himpl_ghost) (mid := MachineImpl). *)
(*       4: { destruct core. *)
(*            - prop_pose_with_custom Foo CP_impl_addr_preserve0 Hfoo. *)
(*              rewrite interp_fancy_spred2_using_impl_only in Foo; eauto. *)
(*            - prop_pose_with_custom Foo CP_impl_addr_preserve1 Hfoo. *)
(*              rewrite interp_fancy_spred2_using_impl_only in Foo; eauto. *)
(*          } *)
(*       all: auto. *)
(*     } *)

(*     assert (req_addrs_in_range core spec_st' ghost) as hspec_req'. *)
(*     { eapply req_addrs_in_range_preserved with (1 := hspec_ghost) (mid := MachineSpec). *)
(*       4: { prop_pose_with_custom Foo CP_spec_addr_preserve Hfoo. *)
(*            destruct core; rewrite interp_fancy_spred2_using_spec_only in Foo; eauto. *)
(*          } *)
(*       all: auto. *)
(*     } *)

(*     constructor. *)
(*     - prop_apply_with_custom CP_push_sim Hfoo. *)
(*     - constructor; auto. *)
(*       + rewrite discharge_and_left with (x := true = true) by auto. *)
(*         destruct core. *)
(*         * prop_apply_with_custom CP_impl_push_zero Hfoo. *)
(*         * prop_pose_with_custom H CP_impl_push_zero Hfoo. cbn in H. split_cases; auto. *)
(*       + intros. *)
(*         prop_pose_with_custom Hrange CP_impl_push_in_range0 Hfoo. (* cbn in Hrange. *) *)
(*         rewrite interp_fancy_spred2_using_impl_only in Hrange by auto. *)
(*         eapply push_other_core_not_in_range_preserved with (2 := himpl_ghost'); eauto. *)
(*         { destruct core. *)
(*           * prop_apply_with_custom CP_impl_push_in_range1 Hfoo. (* cbn in Hrange. *) *)
(*           * eauto. *)
(*         } *)
(*         all: reflexivity. *)
(*       + discriminate. *)
(*       + propositional; destruct core0; cbn. *)
(*         * prop_apply_with_custom CP_post_ext_mem_core0 Hfoo. *)
(*         * prop_apply_with_custom CP_post_ext_mem_core1 Hfoo. *)
(*     - constructor; auto. *)
(*       + prop_pose_with_custom H CP_spec_push_zero Hfoo. cbn in H. split_cases; auto. *)
(*       + unfold get_valid_addr_from_push_req. *)
(*         prop_pose_with_custom H CP_spec_push_zero Hfoo. cbn in H. *)
(*         intro. split_cases. *)
(*         * consider @unsafe_get_field. consider @success_or_default. *)
(*           bash_destruct H. simpl_match. destruct_match; auto. *)
(*           setoid_rewrite Heqr in Heqr0. simplify. auto. *)
(*         * setoid_rewrite H in H0. destruct core; discriminate. *)
(*       + discriminate . *)
(*       + discriminate. *)
(*     - destruct core0. *)
(*       + prop_apply_with_custom CP_purge_preserve0 Hfoo. *)
(*       + prop_apply_with_custom CP_purge_preserve1 Hfoo. *)
(*     - constructor. *)
(*       + destruct core0. *)
(*         * prop_apply_with_custom CP_post_ext_mem_core0 Hfoo. *)
(*         * prop_apply_with_custom CP_post_ext_mem_core1 Hfoo. *)
(*       + prop_apply_with_custom CP_shreq_write_sim Hfoo. *)
(*       + constructor; auto. *)
(*         * prop_apply_with_custom CP_sim_regs Hfoo. *)
(*         * eapply req_addrs_not_in_range_preserved; eauto. *)
(*            4: { destruct core. *)
(*                 - prop_pose_with_custom Foo CP_impl_addr_preserve1 Hfoo. *)
(*                   rewrite interp_fancy_spred2_using_impl_only in Foo; eauto. *)
(*                 - prop_pose_with_custom Foo CP_impl_addr_preserve0 Hfoo. *)
(*                   rewrite interp_fancy_spred2_using_impl_only in Foo; eauto. *)
(*            } *)
(*            all: auto. *)
(*         * prop_apply_with_custom CP_spec_shreq_invalid Hfoo. *)
(*         * prop_apply_with_custom CP_impl_shreq_invalid Hfoo. *)
(*         * constructor. *)
(*           { prop_apply_with_custom CP_impl_purged0 Hfoo. } *)
(*           { prop_apply_with_custom CP_impl_purged1 Hfoo. } *)
(*   Qed. *)

(*   Theorem interp_mem_sim0: *)
(*    sim_interp_scheduler_satisfies_spec *)
(*      Implementation.Machine.SM.reg_type_env _ext_fn_tys *)
(*      Memory._int_fns Memory._int_fns *)
(*      Memory._struct_defs Memory._struct_defs *)
(*      (fun rl : memory_rule_name_t => id_transform_action snd (Memory.rules rl)) *)
(*      (fun rl : memory_rule_name_t => id_transform_action snd (Memory.rules rl)) *)
(*      Memory.schedule Implementation.Core0Machine.mem0_schedule enclave_config *)
(*      (fun impl_st impl_sigma impl_st' impl_ext spec_st spec_sigma spec_st' spec_ext ghost => *)
(*         SimPreStepMem CoreId0 impl_st spec_st impl_sigma spec_sigma ghost) *)
(*      (SimPostStepMem CoreId0). *)
(*   Proof. *)
(*     specialize TEST_interp_mem_sim0. *)
(*     unfold sim_interp_scheduler_satisfies_spec. *)
(*     intros htest. *)
(*     intros * hwf_impl hwf_spec hwf_impl_sigma hwf_spec_sigma hwf_impl_fns hwf_spec_fns *)
(*              himpl_step hspec_step hpre. *)
(*     specialize typecheck_scheduler_correct'' with (5 := himpl_step) (2 := hwf_impl) (3 := hwf_impl_sigma) (4 := hwf_impl_fns) (1 := eq_refl). intros (hwf_impl' & wf_impl_ext'). *)
(*     specialize typecheck_scheduler_correct'' with (5 := hspec_step) (2 := hwf_spec) (3 := hwf_spec_sigma) (4 := hwf_spec_fns) (1 := eq_refl). intros (hwf_spec' & wf_spec_ext'). *)
(*     split_ands_in_goal; auto. *)
(*     specialize htest with (7 := himpl_step) (8 := hspec_step) (ghost := ghost). propositional. *)
(*     assert_pre_as hpre' htest. *)
(*     { eapply SimPreStepMem'_implies; auto. *)
(*       - apply strong_WF_state_weaken. auto. *)
(*       - apply strong_WF_state_weaken. auto. *)
(*     } *)
(*     propositional. *)
(*     propositional. *)

(*     apply SimPostStepMem'_implies; auto. *)
(*     - apply strong_WF_state_weaken. auto. *)
(*     - apply strong_WF_state_weaken. auto. *)
(*     - apply strong_WF_state_weaken. auto. *)
(*     - apply strong_WF_state_weaken. auto. *)
(*     - eapply SimInvariant__valid_addrs__impl. eapply SimPreStepMem__custom. eauto. *)
(*     - eapply SimInvariant__valid_addrs__spec. eapply SimPreStepMem__custom. eauto. *)
(*     - eapply SimInvariant__valid_addrs__impl_other. eapply SimPreStepMem__custom; eauto. *)
(*   Qed. *)

(*   Corollary SimPreStepMem__preserved__unchanged_spec: *)
(*   forall core impl_st spec_st config spec_st' impl_sigma spec_sigma , *)
(*     SimPreStepMem core impl_st spec_st impl_sigma spec_sigma config -> *)
(*     (forall reg, (In reg (([Memory.(_mid turn); (_mid SHReq); REG_SHResp] ++ (map fst (private_mem_regs core))) ++ (ext_mem_regs core) )) -> *)
(*                               spec_st.[_id reg] = spec_st'.[_id reg]) -> *)
(*     SimPreStepMem core impl_st spec_st' impl_sigma spec_sigma config. *)
(*   Proof. *)
(*     intros * hpre hunchanged. *)
(*     destruct hpre. *)
(*     destruct SimPreStepMem__custom0. *)
(*     constructor; consider custom_SimPreStepMem; auto. *)
(*     - rewrite<-hunchanged; auto. *)
(*       destruct core; solve_In_to_find. *)
(*     - intros. rewrite<-hunchanged; auto. *)
(*       destruct core; solve_In_to_find. *)
(*     - intro. rewrite<-hunchanged; auto. *)
(*       destruct core; solve_In_to_find. *)
(*     - constructor; auto. *)
(*       + intros. rewrite<-hunchanged; auto. *)
(*         eapply In_subset with (2 := H). destruct core; vm_compute; reflexivity. *)
(*       + consider req_addrs_in_range. consider fifo_addrs_in_range. *)
(*         destruct core; repeat rewrite<-hunchanged; auto; try solve_In_to_find. *)
(*       + rewrite<-hunchanged; auto. *)
(*         destruct core; solve_In_to_find. *)
(*   Qed. *)
(*   Corollary SimPreStepMem__preserved__unchanged_impl: *)
(*   forall core impl_st spec_st config impl_st' impl_sigma spec_sigma, *)
(*     SimPreStepMem core impl_st spec_st impl_sigma spec_sigma config -> *)
(*     (forall reg, (In reg (map fst (Memory.reg_list))) -> impl_st.[_id reg] = impl_st'.[_id reg]) -> *)
(*     SimPreStepMem core impl_st' spec_st impl_sigma spec_sigma config. *)
(*   Proof. *)
(*     intros * hpre hunchanged. *)
(*     destruct hpre. *)
(*     destruct SimPreStepMem__custom0. *)
(*     constructor; consider custom_SimPreStepMem; auto. *)
(*     - rewrite<-hunchanged; auto. *)
(*       destruct core; solve_In_to_find. *)
(*     - constructor; auto. *)
(*       + eapply SimPreStepMem__buffer0. *)
(*         rewrite hunchanged; auto. solve_In_to_find. *)
(*       + rewrite<-hunchanged; auto; [ | solve_In_to_find]. *)
(*         rewrite<-hunchanged in H; auto; [ | solve_In_to_find]. *)
(*         eapply SimPreStepMem__buffer0; eauto. *)
(*     - intros.  rewrite<-hunchanged in H; auto. solve_In_to_find. *)
(*     - intros. *)
(*       specialize (SimPreStepMem__buffer_correct_core0 core'). *)
(*       destruct core'; cbn - [_id]; *)
(*         intro; repeat (rewrite<-hunchanged; auto; [ | solve_In_to_find]); *)
(*         cbn - [_id] in SimPreStepMem__buffer_correct_core0; eauto. *)
(*     - constructor; auto. *)
(*       + intros. rewrite<-hunchanged; auto. destruct core; eapply In_subset with (2 := H); vm_compute; reflexivity. *)
(*       + consider req_addrs_in_range. consider fifo_addrs_in_range. *)
(*         destruct core; repeat rewrite<-hunchanged; auto; solve_In_to_find. *)
(*       + consider req_addrs_not_in_range. consider fifo_addrs_not_in_range. *)
(*         destruct core; unfold other_core in *; repeat rewrite<-hunchanged; auto; try solve_In_to_find. *)
(*       + rewrite<-hunchanged; auto. solve_In_to_find. *)
(*       + destruct SimInvariant__impl0. *)
(*         constructor. *)
(*         * cbn - [_id]. repeat rewrite<-hunchanged; auto; solve_In_to_find. *)
(*         * cbn - [_id]. repeat rewrite<-hunchanged; auto; solve_In_to_find. *)
(*   Qed. *)
(* End MemoryProofs. *)
(* Require Import koikaExamples.Enclaves.External. *)
(* Module Mem_ConcreteProof . *)
(*   Module SecurityParams := Empty <+ SecurityParams_sig EnclaveParams. *)
(*   Module Mem_Params := Empty <+ MemoryProofs EnclaveParams SecurityParams. *)
(*   Import Mem_Params. *)
(*   (* Definition test_sched := *) *)
(*   (*   map (fun rl : memory_rule_name_t => (rl, show rl)) *) *)
(*   (*       (* [Rl_doMemReq0; Rl_doExternalMem; Rl_tick]. *) *) *)
(*   (*       [Rl_doMemReq0; Rl_doMemReq1; Rl_doPurge0; Rl_doPurge1; Rl_doExternalMem; *) *)
(*   (*        Rl_doMemResp0; Rl_doMemResp1; Rl_doInit0; Rl_doInit1; Rl_tick]. *) *)
(*   (* Definition test_sched0 := *) *)
(*   (*   map (fun rl : memory_rule_name_t => (rl, show rl)) *) *)
(*   (*       (* [Rl_doMemReq0; Rl_doExternalMem; Rl_tick]. *) *) *)
(*   (*       [Rl_doMemReq0; Rl_doPurge0; Rl_doExternalMem; Rl_doMemResp0; Rl_doInit0; Rl_tick]. *) *)

(*   (*   Definition test_impl_machine : machine_t := *) *)
(*   (*     {| file_registers := Memory.reg_list; *) *)
(*   (*        file_ext_sigma := ext_fn_tys; *) *)
(*   (*        file_struct_defs := Memory.struct_defs; *) *)
(*   (*        file_schedule := preprocess_schedule impl_typecheck_fn Memory.rules  test_sched *) *)
(*   (*     |}. *) *)
(*   (*   Definition test_spec0_machine : machine_t := *) *)
(*   (*     {| file_registers := Memory.reg_list; *) *)
(*   (*        file_ext_sigma := ext_fn_tys; *) *)
(*   (*        file_struct_defs := Memory.struct_defs; *) *)
(*   (*        file_schedule := preprocess_schedule impl_typecheck_fn Memory.rules  test_sched0 *) *)
(*   (*     |}. *) *)
(*   (* Definition file: file_t := *) *)
(*   (*   Eval vm_compute in *) *)
(*   (*   {| file_machines := Product test_impl_machine test_spec0_machine; *) *)
(*   (*      file_assumptions := List.concat (map (fun '(_, p) => (flatten_spred_ands (unfancy p))) (foo_SimPreStepMem CoreId0)); *) *)
(*   (*      file_assertions := List.concat ((map (fun '(_, p) => (flatten_spred_ands (unfancy p)))) (foo_SimPostStepMem CoreId0)) *) *)
(*   (*   |}. *) *)
(*   (* Extraction "../../../Test.ml" struct_sz vect_t file. *) *)
(*   Definition file: file_t := *)
(*     Eval vm_compute in *)
(*     {| file_machines := Product impl_machine spec0_machine impl_schedule spec0_schedule; *)
(*        file_assumptions := preprocess_fancy_spreds (foo_SimPreStepMem CoreId0); *)
(*        file_assertions := preprocess_fancy_spreds (foo_SimPostStepMem CoreId0); *)
(*     |}. *)

(*   Extraction "../../../Test.ml" struct_sz vect_t file. *)
(*   Lemma WF_product_file_sim0: WF_product_file file = true. *)
(*   Proof. *)
(*   Admitted. *)

(*   Theorem smt_sim0_correct: *)
(*     symbolic_evaluate_file_success_product *)
(*       impl_machine spec0_machine impl_schedule spec0_schedule *)
(*       (preprocess_fancy_spreds (foo_SimPreStepMem CoreId0)) *)
(*       (preprocess_fancy_spreds (foo_SimPostStepMem CoreId0)). *)
(*   Proof. *)
(*     intros. *)
(*     specialize symbolic_evaluate_file_success with (file := file). *)
(*   Admitted. *)
(* End Mem_ConcreteProof. *)
